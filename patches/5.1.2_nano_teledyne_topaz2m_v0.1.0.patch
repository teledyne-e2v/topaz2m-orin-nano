From 8c2ac60f4a52c7474139a4b4950e273a1064f67d Mon Sep 17 00:00:00 2001
From: Francis Guindon <francis.guindon@ridgerun.com>
Date: Mon, 4 Mar 2024 11:25:09 -0600
Subject: [PATCH] Squashed commit of the following:

commit d841e788203af69439c6612cf9d95941135e9fe7
Author: Francis Guindon <francis.guindon@ridgerun.com>
Date:   Mon Mar 4 11:22:33 2024 -0600

    Fix defconfig topaz2m driver description

commit ac24511424721b9cd74e544e9d5f45ed469f8af0
Author: Francis Guindon <francis.guindon@ridgerun.com>
Date:   Mon Mar 4 11:09:51 2024 -0600

    Update copyright date

commit f56c7ee89642ecc3ba4fb8bbe376e181c0013836
Author: Francis Guindon <francis.guindon@ridgerun.com>
Date:   Mon Mar 4 10:20:33 2024 -0600

    Update driver version

commit 54ce4e04780396bd2c017cb44d7a71dacd7b951f
Author: Francis Guindon <francis.guindon@ridgerun.com>
Date:   Thu Feb 29 17:01:08 2024 -0600

    Update csi lanes to 1 and 2, and add lane polarity

commit 556ca13669732bd0e145eb06cb0d2e4fb5136253
Author: Francis Guindon <francis.guindon@ridgerun.com>
Date:   Thu Feb 29 09:46:48 2024 -0600

    Remove unused includes

commit bba95f5040603d7a66004b53d69f94e79d305bd4
Author: Francis Guindon <francis.guindon@ridgerun.com>
Date:   Thu Feb 29 09:44:40 2024 -0600

    Add initial device tree

commit 203e1304b365a840e9b43cde8d38509c77bf9381
Author: Francis Guindon <francis.guindon@ridgerun.com>
Date:   Thu Feb 29 08:34:29 2024 -0600

    Port driver sources and video subsystem changes
---
 .../cvb/tegra234-camera-topaz2m.dtsi          | 1194 +++++++
 .../kernel-dts/cvb/tegra234-p3509-a02.dtsi    |    3 +-
 .../cvb/tegra234-p3768-0000-a0.dtsi           |    3 +-
 .../kernel-5.10/arch/arm64/configs/defconfig  |    2 +-
 kernel/nvidia/drivers/media/i2c/Kconfig       |    9 +
 kernel/nvidia/drivers/media/i2c/Makefile      |    1 +
 kernel/nvidia/drivers/media/i2c/topaz2m.c     | 3072 +++++++++++++++++
 .../drivers/media/i2c/topaz2m_mode_tbls.h     | 1270 +++++++
 .../platform/tegra/camera/camera_common.c     |   10 +
 .../platform/tegra/camera/sensor_common.c     |    4 +
 .../platform/tegra/camera/tegracam_core.c     |    6 +-
 .../platform/tegra/camera/tegracam_ctrls.c    |  570 ++-
 .../platform/tegra/camera/tegracam_v4l2.c     |   11 +
 .../platform/tegra/camera/vi/vi2_formats.h    |    6 +
 .../platform/tegra/camera/vi/vi4_formats.h    |    6 +
 .../platform/tegra/camera/vi/vi5_formats.h    |    6 +
 kernel/nvidia/include/media/camera_common.h   |   28 +
 .../nvidia/include/media/tegra-v4l2-camera.h  |   28 +-
 kernel/nvidia/include/media/tegracam_core.h   |    5 +
 19 files changed, 6224 insertions(+), 10 deletions(-)
 create mode 100644 hardware/nvidia/platform/t23x/p3768/kernel-dts/cvb/tegra234-camera-topaz2m.dtsi
 create mode 100644 kernel/nvidia/drivers/media/i2c/topaz2m.c
 create mode 100644 kernel/nvidia/drivers/media/i2c/topaz2m_mode_tbls.h

diff --git a/hardware/nvidia/platform/t23x/p3768/kernel-dts/cvb/tegra234-camera-topaz2m.dtsi b/hardware/nvidia/platform/t23x/p3768/kernel-dts/cvb/tegra234-camera-topaz2m.dtsi
new file mode 100644
index 000000000..5d6782e52
--- /dev/null
+++ b/hardware/nvidia/platform/t23x/p3768/kernel-dts/cvb/tegra234-camera-topaz2m.dtsi
@@ -0,0 +1,1194 @@
+/*
+ * Copyright (c) 2024, RidgeRun, LLC. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <dt-bindings/media/camera.h>
+
+/*
+NOTE: See the following link as a refference:
+https://docs.nvidia.com/jetson/l4t/index.html#page/Tegra%20Linux%20Driver%20Package%20Development%20Guide/camera_sensor_prog.html
+*/
+
+#define CAM0_PWDN	TEGRA234_MAIN_GPIO(H, 6)
+#define CAM1_PWDN	TEGRA234_MAIN_GPIO(AC, 0)
+
+#define CAM_I2C_MUX TEGRA234_AON_GPIO(CC, 3)
+
+/ {
+    tegra-capture-vi {
+        num-channels = <2>;
+        ports {
+            #address-cells = <1>;
+            #size-cells = <0>;
+            port@0 {
+                reg = <0>;
+                topaz2m_vi_in0: endpoint {
+                    port-index = <1>;
+                    bus-width = <2>;
+                    remote-endpoint = <&topaz2m_csi_out0>;
+                    status = "okay";
+                };
+            };
+            port@1 {
+                reg = <1>;
+                topaz2m_vi_in1: endpoint {
+                    port-index = <2>;
+                    bus-width = <2>;
+                    remote-endpoint = <&topaz2m_csi_out1>;
+                    status = "okay";
+                };
+            };
+        };
+    };
+
+    host1x@13e00000 {
+        nvcsi@15a00000 {
+            num-channels = <2>;
+            #address-cells = <1>;
+            #size-cells = <0>;
+            channel@0 {
+                reg = <0>;
+                ports {
+                    #address-cells = <1>;
+                    #size-cells = <0>;
+                    port@0 {
+                        reg = <0>;
+                        status = "okay";
+                        topaz2m_csi_in0: endpoint@0 {
+                            port-index = <1>;
+                            bus-width = <2>;
+                            remote-endpoint = <&topaz2m_out0>;
+                            status = "okay";
+                        };
+                    };
+                    port@1 {
+                        reg = <1>;
+                        status = "okay";
+                        topaz2m_csi_out0: endpoint@1 {
+                            remote-endpoint = <&topaz2m_vi_in0>;
+                            status = "okay";
+                        };
+                    };
+                };
+            };
+            channel@1 {
+                reg = <1>;
+                ports {
+                    #address-cells = <1>;
+                    #size-cells = <0>;
+                    port@2 {
+                        reg = <0>;
+                        status = "okay";
+                        topaz2m_csi_in1: endpoint@2 {
+                            port-index = <2>;
+                            bus-width = <2>;
+                            remote-endpoint = <&topaz2m_out1>;
+                            status = "okay";
+                        };
+                    };
+                    port@3 {
+                        reg = <1>;
+                        status = "okay";
+                        topaz2m_csi_out1: endpoint@3 {
+                            remote-endpoint = <&topaz2m_vi_in1>;
+                            status = "okay";
+                        };
+                    };
+                };
+            };
+        };
+    };
+
+    cam_i2cmux {
+        compatible = "i2c-mux-gpio";
+        #address-cells = <1>;
+        #size-cells = <0>;
+        mux-gpios = <&tegra_aon_gpio CAM_I2C_MUX GPIO_ACTIVE_HIGH>;
+        i2c-parent = <&cam_i2c>;
+        status = "okay";
+        i2c@0 {
+            status = "okay";
+            reg = <0>;
+            #address-cells = <1>;
+            #size-cells = <0>;
+            topaz2m_b@10 {
+                compatible = "teledyne,topaz2m";
+                reg = <0x10>;
+                status = "okay";
+                devnode = "video0";
+                pwdn-gpios = <&tegra_main_gpio CAM0_PWDN GPIO_ACTIVE_HIGH>;
+                physical_w = "7.65";
+                physical_h = "4.45";
+                sensor_model = "topaz2m";
+                use_sensor_mode_id = "true";
+
+                /* Internal self-trigger modes */
+
+                mode0 { /* TOPAZ2M_MODE_1920x1080_65FPS */
+                    mclk_khz = "50000";
+                    num_lanes = "2";
+                    tegra_sinterface = "serial_b";
+                    phy_mode = "DPHY";
+                    discontinuous_clk = "no";
+                    dpcm_enable = "false";
+                    cil_settletime = "0";
+                    active_w = "1920";
+                    active_h = "1080";
+                    mode_type = "bayer";
+                    csi_pixel_bit_depth = "10";
+                    pixel_phase = "rggb";
+                    readout_orientation = "0";
+                    line_length = "1920";
+                    inherent_gain = "1";
+                    pix_clk_hz = "240000000";
+                    lane_polarity = "6";
+
+                    gain_factor = "1";
+                    framerate_factor = "1000000";
+                    exposure_factor = "1000000";
+                    min_gain_val = "1";    /* Min Raw gain */
+                    max_gain_val = "256"; /* Max Raw gain */
+                    step_gain_val = "1";
+                    default_gain = "1"; /* 1.00x */
+                    min_hdr_ratio = "1";
+                    max_hdr_ratio = "1";
+                    min_framerate = "5000000";
+                    max_framerate = "65000000";
+                    step_framerate = "1000000";
+                    default_framerate = "65000000"; /* 65.0 fps */
+                    min_exp_time = "5"; /* us */
+                    max_exp_time = "200000"; /* us */
+                    step_exp_time = "1";
+                    default_exp_time = "14040"; /* us */
+                    embedded_metadata_height = "0";
+                };
+
+                mode1 { /* TOPAZ2M_MODE_1920x800_80FPS_RAW10 */
+                    mclk_khz = "50000";
+                    num_lanes = "2";
+                    tegra_sinterface = "serial_b";
+                    phy_mode = "DPHY";
+                    discontinuous_clk = "no";
+                    dpcm_enable = "false";
+                    cil_settletime = "0";
+                    active_w = "1920";
+                    active_h = "800";
+                    mode_type = "bayer";
+                    csi_pixel_bit_depth = "10";
+                    pixel_phase = "rggb";
+                    readout_orientation = "0";
+                    line_length = "1920";
+                    inherent_gain = "1";
+                    pix_clk_hz = "240000000";
+                    lane_polarity = "6";
+
+                    gain_factor = "1";
+                    framerate_factor = "1000000";
+                    exposure_factor = "1000000";
+                    min_gain_val = "1";    /* Min Raw gain */
+                    max_gain_val = "256"; /* Max Raw gain */
+                    step_gain_val = "1";
+                    default_gain = "1"; /* 1.00x */
+                    min_hdr_ratio = "1";
+                    max_hdr_ratio = "1";
+                    min_framerate = "5000000";
+                    max_framerate = "80000000";
+                    step_framerate = "1000000";
+                    default_framerate = "80000000"; /* 80.0 fps */
+                    min_exp_time = "5"; /* us */
+                    max_exp_time = "200000"; /* us */
+                    step_exp_time = "1";
+                    default_exp_time = "10400"; /* us */
+                    embedded_metadata_height = "0";
+                };
+
+                mode2 { /* TOPAZ2M_MODE_1920x1080_100FPS_RAW8 */
+                    mclk_khz = "50000";
+                    num_lanes = "2";
+                    tegra_sinterface = "serial_b";
+                    phy_mode = "DPHY";
+                    discontinuous_clk = "no";
+                    dpcm_enable = "false";
+                    cil_settletime = "0";
+                    active_w = "1920";
+                    active_h = "1080";
+                    mode_type = "grey";
+                    csi_pixel_bit_depth = "8";
+                    pixel_phase = "";
+                    readout_orientation = "0";
+                    line_length = "1920";
+                    inherent_gain = "1";
+                    pix_clk_hz = "300000000";
+                    lane_polarity = "6";
+
+                    gain_factor = "1";
+                    framerate_factor = "1000000";
+                    exposure_factor = "1000000";
+                    min_gain_val = "1";    /* Min Raw gain */
+                    max_gain_val = "256"; /* Max Raw gain */
+                    step_gain_val = "1";
+                    default_gain = "1"; /* 1.00x */
+                    min_hdr_ratio = "1";
+                    max_hdr_ratio = "1";
+                    min_framerate = "5000000";
+                    max_framerate = "100000000";
+                    step_framerate = "1000000";
+                    default_framerate = "100000000"; /* 100.0 fps */
+                    min_exp_time = "5"; /* us */
+                    max_exp_time = "200000"; /* us */
+                    step_exp_time = "1";
+                    default_exp_time = "9180"; /* us */
+                    embedded_metadata_height = "0";
+                };
+
+                mode3 { /* TOPAZ2M_MODE_1920x800_130FPS_RAW8 */
+                    mclk_khz = "50000";
+                    num_lanes = "2";
+                    tegra_sinterface = "serial_b";
+                    phy_mode = "DPHY";
+                    discontinuous_clk = "no";
+                    dpcm_enable = "false";
+                    cil_settletime = "0";
+                    active_w = "1920";
+                    active_h = "800";
+                    mode_type = "grey";
+                    csi_pixel_bit_depth = "8";
+                    pixel_phase = "";
+                    readout_orientation = "0";
+                    line_length = "1920";
+                    inherent_gain = "1";
+                    pix_clk_hz = "300000000";
+                    lane_polarity = "6";
+
+                    gain_factor = "1";
+                    framerate_factor = "1000000";
+                    exposure_factor = "1000000";
+                    min_gain_val = "1";    /* Min Raw gain */
+                    max_gain_val = "256"; /* Max Raw gain */
+                    step_gain_val = "1";
+                    default_gain = "1"; /* 1.00x */
+                    min_hdr_ratio = "1";
+                    max_hdr_ratio = "1";
+                    min_framerate = "5000000";
+                    max_framerate = "130000000";
+                    step_framerate = "1000000";
+                    default_framerate = "130000000"; /* 130.0 fps */
+                    min_exp_time = "5"; /* us */
+                    max_exp_time = "200000"; /* us */
+                    step_exp_time = "1";
+                    default_exp_time = "6800"; /* us */
+                    embedded_metadata_height = "0";
+                };
+
+                /* External Frame Trigger modes */
+
+                mode4 { /* TOPAZ2M_MODE_1920x1080_65FPS */
+                    mclk_khz = "50000";
+                    num_lanes = "2";
+                    tegra_sinterface = "serial_b";
+                    phy_mode = "DPHY";
+                    discontinuous_clk = "no";
+                    dpcm_enable = "false";
+                    cil_settletime = "0";
+                    active_w = "1920";
+                    active_h = "1080";
+                    mode_type = "bayer";
+                    csi_pixel_bit_depth = "10";
+                    pixel_phase = "rggb";
+                    readout_orientation = "0";
+                    line_length = "1920";
+                    inherent_gain = "1";
+                    pix_clk_hz = "240000000";
+                    lane_polarity = "6";
+
+                    gain_factor = "1";
+                    framerate_factor = "1000000";
+                    exposure_factor = "1000000";
+                    min_gain_val = "1";    /* Min Raw gain */
+                    max_gain_val = "256"; /* Max Raw gain */
+                    step_gain_val = "1";
+                    default_gain = "1"; /* 1.00x */
+                    min_hdr_ratio = "1";
+                    max_hdr_ratio = "1";
+                    min_framerate = "5000000";
+                    max_framerate = "65000000";
+                    step_framerate = "1000000";
+                    default_framerate = "65000000"; /* 65.0 fps */
+                    min_exp_time = "5"; /* us */
+                    max_exp_time = "200000"; /* us */
+                    step_exp_time = "1";
+                    default_exp_time = "14040"; /* us */
+                    embedded_metadata_height = "0";
+                };
+
+                mode5 { /* TOPAZ2M_MODE_1920x800_80FPS_RAW10 */
+                    mclk_khz = "50000";
+                    num_lanes = "2";
+                    tegra_sinterface = "serial_b";
+                    phy_mode = "DPHY";
+                    discontinuous_clk = "no";
+                    dpcm_enable = "false";
+                    cil_settletime = "0";
+                    active_w = "1920";
+                    active_h = "800";
+                    mode_type = "bayer";
+                    csi_pixel_bit_depth = "10";
+                    pixel_phase = "rggb";
+                    readout_orientation = "0";
+                    line_length = "1920";
+                    inherent_gain = "1";
+                    pix_clk_hz = "240000000";
+                    lane_polarity = "6";
+
+                    gain_factor = "1";
+                    framerate_factor = "1000000";
+                    exposure_factor = "1000000";
+                    min_gain_val = "1";    /* Min Raw gain */
+                    max_gain_val = "256"; /* Max Raw gain */
+                    step_gain_val = "1";
+                    default_gain = "1"; /* 1.00x */
+                    min_hdr_ratio = "1";
+                    max_hdr_ratio = "1";
+                    min_framerate = "5000000";
+                    max_framerate = "80000000";
+                    step_framerate = "1000000";
+                    default_framerate = "80000000"; /* 80.0 fps */
+                    min_exp_time = "5"; /* us */
+                    max_exp_time = "200000"; /* us */
+                    step_exp_time = "1";
+                    default_exp_time = "10400"; /* us */
+                    embedded_metadata_height = "0";
+                };
+
+                mode6 { /* TOPAZ2M_MODE_1920x1080_100FPS_RAW8 */
+                    mclk_khz = "50000";
+                    num_lanes = "2";
+                    tegra_sinterface = "serial_b";
+                    phy_mode = "DPHY";
+                    discontinuous_clk = "no";
+                    dpcm_enable = "false";
+                    cil_settletime = "0";
+                    active_w = "1920";
+                    active_h = "1080";
+                    mode_type = "grey";
+                    csi_pixel_bit_depth = "8";
+                    pixel_phase = "";
+                    readout_orientation = "0";
+                    line_length = "1920";
+                    inherent_gain = "1";
+                    pix_clk_hz = "300000000";
+                    lane_polarity = "6";
+
+                    gain_factor = "1";
+                    framerate_factor = "1000000";
+                    exposure_factor = "1000000";
+                    min_gain_val = "1";    /* Min Raw gain */
+                    max_gain_val = "256"; /* Max Raw gain */
+                    step_gain_val = "1";
+                    default_gain = "1"; /* 1.00x */
+                    min_hdr_ratio = "1";
+                    max_hdr_ratio = "1";
+                    min_framerate = "5000000";
+                    max_framerate = "100000000";
+                    step_framerate = "1000000";
+                    default_framerate = "100000000"; /* 100.0 fps */
+                    min_exp_time = "5"; /* us */
+                    max_exp_time = "200000"; /* us */
+                    step_exp_time = "1";
+                    default_exp_time = "9180"; /* us */
+                    embedded_metadata_height = "0";
+                };
+
+                mode7 { /* TOPAZ2M_MODE_1920x800_130FPS_RAW8 */
+                    mclk_khz = "50000";
+                    num_lanes = "2";
+                    tegra_sinterface = "serial_b";
+                    phy_mode = "DPHY";
+                    discontinuous_clk = "no";
+                    dpcm_enable = "false";
+                    cil_settletime = "0";
+                    active_w = "1920";
+                    active_h = "800";
+                    mode_type = "grey";
+                    csi_pixel_bit_depth = "8";
+                    pixel_phase = "";
+                    readout_orientation = "0";
+                    line_length = "1920";
+                    inherent_gain = "1";
+                    pix_clk_hz = "300000000";
+                    lane_polarity = "6";
+
+                    gain_factor = "1";
+                    framerate_factor = "1000000";
+                    exposure_factor = "1000000";
+                    min_gain_val = "1";    /* Min Raw gain */
+                    max_gain_val = "256"; /* Max Raw gain */
+                    step_gain_val = "1";
+                    default_gain = "1"; /* 1.00x */
+                    min_hdr_ratio = "1";
+                    max_hdr_ratio = "1";
+                    min_framerate = "5000000";
+                    max_framerate = "130000000";
+                    step_framerate = "1000000";
+                    default_framerate = "130000000"; /* 130.0 fps */
+                    min_exp_time = "5"; /* us */
+                    max_exp_time = "200000"; /* us */
+                    step_exp_time = "1";
+                    default_exp_time = "6800"; /* us */
+                    embedded_metadata_height = "0";
+                };
+
+                /* External ITC Trigger modes */
+
+                mode8 { /* TOPAZ2M_MODE_1920x1080_65FPS */
+                    mclk_khz = "50000";
+                    num_lanes = "2";
+                    tegra_sinterface = "serial_b";
+                    phy_mode = "DPHY";
+                    discontinuous_clk = "no";
+                    dpcm_enable = "false";
+                    cil_settletime = "0";
+                    active_w = "1920";
+                    active_h = "1080";
+                    mode_type = "bayer";
+                    csi_pixel_bit_depth = "10";
+                    pixel_phase = "rggb";
+                    readout_orientation = "0";
+                    line_length = "1920";
+                    inherent_gain = "1";
+                    pix_clk_hz = "240000000";
+                    lane_polarity = "6";
+
+                    gain_factor = "1";
+                    framerate_factor = "1000000";
+                    exposure_factor = "1000000";
+                    min_gain_val = "1";    /* Min Raw gain */
+                    max_gain_val = "256"; /* Max Raw gain */
+                    step_gain_val = "1";
+                    default_gain = "1"; /* 1.00x */
+                    min_hdr_ratio = "1";
+                    max_hdr_ratio = "1";
+                    min_framerate = "5000000";
+                    max_framerate = "65000000";
+                    step_framerate = "1000000";
+                    default_framerate = "65000000"; /* 65.0 fps */
+                    min_exp_time = "5"; /* us */
+                    max_exp_time = "200000"; /* us */
+                    step_exp_time = "1";
+                    default_exp_time = "14040"; /* us */
+                    embedded_metadata_height = "0";
+                };
+
+                mode9 { /* TOPAZ2M_MODE_1920x800_80FPS_RAW10 */
+                    mclk_khz = "50000";
+                    num_lanes = "2";
+                    tegra_sinterface = "serial_b";
+                    phy_mode = "DPHY";
+                    discontinuous_clk = "no";
+                    dpcm_enable = "false";
+                    cil_settletime = "0";
+                    active_w = "1920";
+                    active_h = "800";
+                    mode_type = "bayer";
+                    csi_pixel_bit_depth = "10";
+                    pixel_phase = "rggb";
+                    readout_orientation = "0";
+                    line_length = "1920";
+                    inherent_gain = "1";
+                    pix_clk_hz = "240000000";
+                    lane_polarity = "6";
+
+                    gain_factor = "1";
+                    framerate_factor = "1000000";
+                    exposure_factor = "1000000";
+                    min_gain_val = "1";    /* Min Raw gain */
+                    max_gain_val = "256"; /* Max Raw gain */
+                    step_gain_val = "1";
+                    default_gain = "1"; /* 1.00x */
+                    min_hdr_ratio = "1";
+                    max_hdr_ratio = "1";
+                    min_framerate = "5000000";
+                    max_framerate = "80000000";
+                    step_framerate = "1000000";
+                    default_framerate = "80000000"; /* 80.0 fps */
+                    min_exp_time = "5"; /* us */
+                    max_exp_time = "200000"; /* us */
+                    step_exp_time = "1";
+                    default_exp_time = "10400"; /* us */
+                    embedded_metadata_height = "0";
+                };
+
+                mode10 { /* TOPAZ2M_MODE_1920x1080_100FPS_RAW8 */
+                    mclk_khz = "50000";
+                    num_lanes = "2";
+                    tegra_sinterface = "serial_b";
+                    phy_mode = "DPHY";
+                    discontinuous_clk = "no";
+                    dpcm_enable = "false";
+                    cil_settletime = "0";
+                    active_w = "1920";
+                    active_h = "1080";
+                    mode_type = "grey";
+                    csi_pixel_bit_depth = "8";
+                    pixel_phase = "";
+                    readout_orientation = "0";
+                    line_length = "1920";
+                    inherent_gain = "1";
+                    pix_clk_hz = "300000000";
+                    lane_polarity = "6";
+
+                    gain_factor = "1";
+                    framerate_factor = "1000000";
+                    exposure_factor = "1000000";
+                    min_gain_val = "1";    /* Min Raw gain */
+                    max_gain_val = "256"; /* Max Raw gain */
+                    step_gain_val = "1";
+                    default_gain = "1"; /* 1.00x */
+                    min_hdr_ratio = "1";
+                    max_hdr_ratio = "1";
+                    min_framerate = "5000000";
+                    max_framerate = "100000000";
+                    step_framerate = "1000000";
+                    default_framerate = "100000000"; /* 100.0 fps */
+                    min_exp_time = "5"; /* us */
+                    max_exp_time = "200000"; /* us */
+                    step_exp_time = "1";
+                    default_exp_time = "9180"; /* us */
+                    embedded_metadata_height = "0";
+                };
+
+                mode11 { /* TOPAZ2M_MODE_1920x800_130FPS_RAW8 */
+                    mclk_khz = "50000";
+                    num_lanes = "2";
+                    tegra_sinterface = "serial_b";
+                    phy_mode = "DPHY";
+                    discontinuous_clk = "no";
+                    dpcm_enable = "false";
+                    cil_settletime = "0";
+                    active_w = "1920";
+                    active_h = "800";
+                    mode_type = "grey";
+                    csi_pixel_bit_depth = "8";
+                    pixel_phase = "";
+                    readout_orientation = "0";
+                    line_length = "1920";
+                    inherent_gain = "1";
+                    pix_clk_hz = "300000000";
+                    lane_polarity = "6";
+
+                    gain_factor = "1";
+                    framerate_factor = "1000000";
+                    exposure_factor = "1000000";
+                    min_gain_val = "1";    /* Min Raw gain */
+                    max_gain_val = "256"; /* Max Raw gain */
+                    step_gain_val = "1";
+                    default_gain = "1"; /* 1.00x */
+                    min_hdr_ratio = "1";
+                    max_hdr_ratio = "1";
+                    min_framerate = "5000000";
+                    max_framerate = "130000000";
+                    step_framerate = "1000000";
+                    default_framerate = "130000000"; /* 130.0 fps */
+                    min_exp_time = "5"; /* us */
+                    max_exp_time = "200000"; /* us */
+                    step_exp_time = "1";
+                    default_exp_time = "6800"; /* us */
+                    embedded_metadata_height = "0";
+                };
+
+                ports {
+                    #address-cells = <1>;
+                    #size-cells = <0>;
+
+                    port@0 {
+                        reg = <0>;
+                        topaz2m_out0: endpoint {
+                            port-index = <1>;
+                            bus-width = <2>;
+                            remote-endpoint = <&topaz2m_csi_in0>;
+                        };
+                    };
+                };
+            };
+        };
+
+        i2c@1 {
+            status = "okay";
+            reg = <1>;
+            #address-cells = <1>;
+            #size-cells = <0>;
+            topaz2m_c@10 {
+                compatible = "teledyne,topaz2m";
+                reg = <0x10>;
+                status = "okay";
+                devnode = "video1";
+                pwdn-gpios = <&tegra_main_gpio CAM1_PWDN GPIO_ACTIVE_HIGH>;
+                physical_w = "7.65";
+                physical_h = "4.45";
+                sensor_model = "topaz2m";
+                use_sensor_mode_id = "true";
+
+                /* Internal self-trigger modes */
+
+                mode0 { /* TOPAZ2M_MODE_1920x1080_65FPS */
+                    mclk_khz = "50000";
+                    num_lanes = "2";
+                    tegra_sinterface = "serial_c";
+                    phy_mode = "DPHY";
+                    discontinuous_clk = "no";
+                    dpcm_enable = "false";
+                    cil_settletime = "0";
+                    active_w = "1920";
+                    active_h = "1080";
+                    mode_type = "bayer";
+                    csi_pixel_bit_depth = "10";
+                    pixel_phase = "rggb";
+                    readout_orientation = "0";
+                    line_length = "1920";
+                    inherent_gain = "1";
+                    pix_clk_hz = "240000000";
+                    lane_polarity = "0";
+
+                    gain_factor = "1";
+                    framerate_factor = "1000000";
+                    exposure_factor = "1000000";
+                    min_gain_val = "1";    /* Min Raw gain */
+                    max_gain_val = "256"; /* Max Raw gain */
+                    step_gain_val = "1";
+                    default_gain = "1"; /* 1.00x */
+                    min_hdr_ratio = "1";
+                    max_hdr_ratio = "1";
+                    min_framerate = "5000000";
+                    max_framerate = "65000000";
+                    step_framerate = "1000000";
+                    default_framerate = "65000000"; /* 65.0 fps */
+                    min_exp_time = "5"; /* us */
+                    max_exp_time = "200000"; /* us */
+                    step_exp_time = "1";
+                    default_exp_time = "14040"; /* us */
+                    embedded_metadata_height = "0";
+                };
+
+                mode1 { /* TOPAZ2M_MODE_1920x800_80FPS_RAW10 */
+                    mclk_khz = "50000";
+                    num_lanes = "2";
+                    tegra_sinterface = "serial_c";
+                    phy_mode = "DPHY";
+                    discontinuous_clk = "no";
+                    dpcm_enable = "false";
+                    cil_settletime = "0";
+                    active_w = "1920";
+                    active_h = "800";
+                    mode_type = "bayer";
+                    csi_pixel_bit_depth = "10";
+                    pixel_phase = "rggb";
+                    readout_orientation = "0";
+                    line_length = "1920";
+                    inherent_gain = "1";
+                    pix_clk_hz = "240000000";
+                    lane_polarity = "0";
+
+                    gain_factor = "1";
+                    framerate_factor = "1000000";
+                    exposure_factor = "1000000";
+                    min_gain_val = "1";    /* Min Raw gain */
+                    max_gain_val = "256"; /* Max Raw gain */
+                    step_gain_val = "1";
+                    default_gain = "1"; /* 1.00x */
+                    min_hdr_ratio = "1";
+                    max_hdr_ratio = "1";
+                    min_framerate = "5000000";
+                    max_framerate = "80000000";
+                    step_framerate = "1000000";
+                    default_framerate = "80000000"; /* 80.0 fps */
+                    min_exp_time = "5"; /* us */
+                    max_exp_time = "200000"; /* us */
+                    step_exp_time = "1";
+                    default_exp_time = "10400"; /* us */
+                    embedded_metadata_height = "0";
+                };
+
+                mode2 { /* TOPAZ2M_MODE_1920x1080_100FPS_RAW8 */
+                    mclk_khz = "50000";
+                    num_lanes = "2";
+                    tegra_sinterface = "serial_c";
+                    phy_mode = "DPHY";
+                    discontinuous_clk = "no";
+                    dpcm_enable = "false";
+                    cil_settletime = "0";
+                    active_w = "1920";
+                    active_h = "1080";
+                    mode_type = "grey";
+                    csi_pixel_bit_depth = "8";
+                    pixel_phase = "";
+                    readout_orientation = "0";
+                    line_length = "1920";
+                    inherent_gain = "1";
+                    pix_clk_hz = "300000000";
+                    lane_polarity = "0";
+
+                    gain_factor = "1";
+                    framerate_factor = "1000000";
+                    exposure_factor = "1000000";
+                    min_gain_val = "1";    /* Min Raw gain */
+                    max_gain_val = "256"; /* Max Raw gain */
+                    step_gain_val = "1";
+                    default_gain = "1"; /* 1.00x */
+                    min_hdr_ratio = "1";
+                    max_hdr_ratio = "1";
+                    min_framerate = "5000000";
+                    max_framerate = "100000000";
+                    step_framerate = "1000000";
+                    default_framerate = "100000000"; /* 100.0 fps */
+                    min_exp_time = "5"; /* us */
+                    max_exp_time = "200000"; /* us */
+                    step_exp_time = "1";
+                    default_exp_time = "9180"; /* us */
+                    embedded_metadata_height = "0";
+                };
+
+                mode3 { /* TOPAZ2M_MODE_1920x800_130FPS_RAW8 */
+                    mclk_khz = "50000";
+                    num_lanes = "2";
+                    tegra_sinterface = "serial_c";
+                    phy_mode = "DPHY";
+                    discontinuous_clk = "no";
+                    dpcm_enable = "false";
+                    cil_settletime = "0";
+                    active_w = "1920";
+                    active_h = "800";
+                    mode_type = "grey";
+                    csi_pixel_bit_depth = "8";
+                    pixel_phase = "";
+                    readout_orientation = "0";
+                    line_length = "1920";
+                    inherent_gain = "1";
+                    pix_clk_hz = "300000000";
+                    lane_polarity = "0";
+
+                    gain_factor = "1";
+                    framerate_factor = "1000000";
+                    exposure_factor = "1000000";
+                    min_gain_val = "1";    /* Min Raw gain */
+                    max_gain_val = "256"; /* Max Raw gain */
+                    step_gain_val = "1";
+                    default_gain = "1"; /* 1.00x */
+                    min_hdr_ratio = "1";
+                    max_hdr_ratio = "1";
+                    min_framerate = "5000000";
+                    max_framerate = "130000000";
+                    step_framerate = "1000000";
+                    default_framerate = "130000000"; /* 130.0 fps */
+                    min_exp_time = "5"; /* us */
+                    max_exp_time = "200000"; /* us */
+                    step_exp_time = "1";
+                    default_exp_time = "6800"; /* us */
+                    embedded_metadata_height = "0";
+                };
+
+                /* External Frame Trigger modes */
+
+                mode4 { /* TOPAZ2M_MODE_1920x1080_65FPS */
+                    mclk_khz = "50000";
+                    num_lanes = "2";
+                    tegra_sinterface = "serial_c";
+                    phy_mode = "DPHY";
+                    discontinuous_clk = "no";
+                    dpcm_enable = "false";
+                    cil_settletime = "0";
+                    active_w = "1920";
+                    active_h = "1080";
+                    mode_type = "bayer";
+                    csi_pixel_bit_depth = "10";
+                    pixel_phase = "rggb";
+                    readout_orientation = "0";
+                    line_length = "1920";
+                    inherent_gain = "1";
+                    pix_clk_hz = "240000000";
+                    lane_polarity = "0";
+
+                    gain_factor = "1";
+                    framerate_factor = "1000000";
+                    exposure_factor = "1000000";
+                    min_gain_val = "1";    /* Min Raw gain */
+                    max_gain_val = "256"; /* Max Raw gain */
+                    step_gain_val = "1";
+                    default_gain = "1"; /* 1.00x */
+                    min_hdr_ratio = "1";
+                    max_hdr_ratio = "1";
+                    min_framerate = "5000000";
+                    max_framerate = "65000000";
+                    step_framerate = "1000000";
+                    default_framerate = "65000000"; /* 65.0 fps */
+                    min_exp_time = "5"; /* us */
+                    max_exp_time = "200000"; /* us */
+                    step_exp_time = "1";
+                    default_exp_time = "14040"; /* us */
+                    embedded_metadata_height = "0";
+                };
+
+                mode5 { /* TOPAZ2M_MODE_1920x800_80FPS_RAW10 */
+                    mclk_khz = "50000";
+                    num_lanes = "2";
+                    tegra_sinterface = "serial_c";
+                    phy_mode = "DPHY";
+                    discontinuous_clk = "no";
+                    dpcm_enable = "false";
+                    cil_settletime = "0";
+                    active_w = "1920";
+                    active_h = "800";
+                    mode_type = "bayer";
+                    csi_pixel_bit_depth = "10";
+                    pixel_phase = "rggb";
+                    readout_orientation = "0";
+                    line_length = "1920";
+                    inherent_gain = "1";
+                    pix_clk_hz = "240000000";
+                    lane_polarity = "0";
+
+                    gain_factor = "1";
+                    framerate_factor = "1000000";
+                    exposure_factor = "1000000";
+                    min_gain_val = "1";    /* Min Raw gain */
+                    max_gain_val = "256"; /* Max Raw gain */
+                    step_gain_val = "1";
+                    default_gain = "1"; /* 1.00x */
+                    min_hdr_ratio = "1";
+                    max_hdr_ratio = "1";
+                    min_framerate = "5000000";
+                    max_framerate = "80000000";
+                    step_framerate = "1000000";
+                    default_framerate = "80000000"; /* 80.0 fps */
+                    min_exp_time = "5"; /* us */
+                    max_exp_time = "200000"; /* us */
+                    step_exp_time = "1";
+                    default_exp_time = "10400"; /* us */
+                    embedded_metadata_height = "0";
+                };
+
+                mode6 { /* TOPAZ2M_MODE_1920x1080_100FPS_RAW8 */
+                    mclk_khz = "50000";
+                    num_lanes = "2";
+                    tegra_sinterface = "serial_c";
+                    phy_mode = "DPHY";
+                    discontinuous_clk = "no";
+                    dpcm_enable = "false";
+                    cil_settletime = "0";
+                    active_w = "1920";
+                    active_h = "1080";
+                    mode_type = "grey";
+                    csi_pixel_bit_depth = "8";
+                    pixel_phase = "";
+                    readout_orientation = "0";
+                    line_length = "1920";
+                    inherent_gain = "1";
+                    pix_clk_hz = "300000000";
+                    lane_polarity = "0";
+
+                    gain_factor = "1";
+                    framerate_factor = "1000000";
+                    exposure_factor = "1000000";
+                    min_gain_val = "1";    /* Min Raw gain */
+                    max_gain_val = "256"; /* Max Raw gain */
+                    step_gain_val = "1";
+                    default_gain = "1"; /* 1.00x */
+                    min_hdr_ratio = "1";
+                    max_hdr_ratio = "1";
+                    min_framerate = "5000000";
+                    max_framerate = "100000000";
+                    step_framerate = "1000000";
+                    default_framerate = "100000000"; /* 100.0 fps */
+                    min_exp_time = "5"; /* us */
+                    max_exp_time = "200000"; /* us */
+                    step_exp_time = "1";
+                    default_exp_time = "9180"; /* us */
+                    embedded_metadata_height = "0";
+                };
+
+                mode7 { /* TOPAZ2M_MODE_1920x800_130FPS_RAW8 */
+                    mclk_khz = "50000";
+                    num_lanes = "2";
+                    tegra_sinterface = "serial_c";
+                    phy_mode = "DPHY";
+                    discontinuous_clk = "no";
+                    dpcm_enable = "false";
+                    cil_settletime = "0";
+                    active_w = "1920";
+                    active_h = "800";
+                    mode_type = "grey";
+                    csi_pixel_bit_depth = "8";
+                    pixel_phase = "";
+                    readout_orientation = "0";
+                    line_length = "1920";
+                    inherent_gain = "1";
+                    pix_clk_hz = "300000000";
+                    lane_polarity = "0";
+
+                    gain_factor = "1";
+                    framerate_factor = "1000000";
+                    exposure_factor = "1000000";
+                    min_gain_val = "1";    /* Min Raw gain */
+                    max_gain_val = "256"; /* Max Raw gain */
+                    step_gain_val = "1";
+                    default_gain = "1"; /* 1.00x */
+                    min_hdr_ratio = "1";
+                    max_hdr_ratio = "1";
+                    min_framerate = "5000000";
+                    max_framerate = "130000000";
+                    step_framerate = "1000000";
+                    default_framerate = "130000000"; /* 130.0 fps */
+                    min_exp_time = "5"; /* us */
+                    max_exp_time = "200000"; /* us */
+                    step_exp_time = "1";
+                    default_exp_time = "6800"; /* us */
+                    embedded_metadata_height = "0";
+                };
+
+                /* External ITC Trigger modes */
+
+                mode8 { /* TOPAZ2M_MODE_1920x1080_65FPS */
+                    mclk_khz = "50000";
+                    num_lanes = "2";
+                    tegra_sinterface = "serial_c";
+                    phy_mode = "DPHY";
+                    discontinuous_clk = "no";
+                    dpcm_enable = "false";
+                    cil_settletime = "0";
+                    active_w = "1920";
+                    active_h = "1080";
+                    mode_type = "bayer";
+                    csi_pixel_bit_depth = "10";
+                    pixel_phase = "rggb";
+                    readout_orientation = "0";
+                    line_length = "1920";
+                    inherent_gain = "1";
+                    pix_clk_hz = "240000000";
+                    lane_polarity = "0";
+
+                    gain_factor = "1";
+                    framerate_factor = "1000000";
+                    exposure_factor = "1000000";
+                    min_gain_val = "1";    /* Min Raw gain */
+                    max_gain_val = "256"; /* Max Raw gain */
+                    step_gain_val = "1";
+                    default_gain = "1"; /* 1.00x */
+                    min_hdr_ratio = "1";
+                    max_hdr_ratio = "1";
+                    min_framerate = "5000000";
+                    max_framerate = "65000000";
+                    step_framerate = "1000000";
+                    default_framerate = "65000000"; /* 65.0 fps */
+                    min_exp_time = "5"; /* us */
+                    max_exp_time = "200000"; /* us */
+                    step_exp_time = "1";
+                    default_exp_time = "14040"; /* us */
+                    embedded_metadata_height = "0";
+                };
+
+                mode9 { /* TOPAZ2M_MODE_1920x800_80FPS_RAW10 */
+                    mclk_khz = "50000";
+                    num_lanes = "2";
+                    tegra_sinterface = "serial_c";
+                    phy_mode = "DPHY";
+                    discontinuous_clk = "no";
+                    dpcm_enable = "false";
+                    cil_settletime = "0";
+                    active_w = "1920";
+                    active_h = "800";
+                    mode_type = "bayer";
+                    csi_pixel_bit_depth = "10";
+                    pixel_phase = "rggb";
+                    readout_orientation = "0";
+                    line_length = "1920";
+                    inherent_gain = "1";
+                    pix_clk_hz = "240000000";
+                    lane_polarity = "0";
+
+                    gain_factor = "1";
+                    framerate_factor = "1000000";
+                    exposure_factor = "1000000";
+                    min_gain_val = "1";    /* Min Raw gain */
+                    max_gain_val = "256"; /* Max Raw gain */
+                    step_gain_val = "1";
+                    default_gain = "1"; /* 1.00x */
+                    min_hdr_ratio = "1";
+                    max_hdr_ratio = "1";
+                    min_framerate = "5000000";
+                    max_framerate = "80000000";
+                    step_framerate = "1000000";
+                    default_framerate = "80000000"; /* 80.0 fps */
+                    min_exp_time = "5"; /* us */
+                    max_exp_time = "200000"; /* us */
+                    step_exp_time = "1";
+                    default_exp_time = "10400"; /* us */
+                    embedded_metadata_height = "0";
+                };
+
+                mode10 { /* TOPAZ2M_MODE_1920x1080_100FPS_RAW8 */
+                    mclk_khz = "50000";
+                    num_lanes = "2";
+                    tegra_sinterface = "serial_c";
+                    phy_mode = "DPHY";
+                    discontinuous_clk = "no";
+                    dpcm_enable = "false";
+                    cil_settletime = "0";
+                    active_w = "1920";
+                    active_h = "1080";
+                    mode_type = "grey";
+                    csi_pixel_bit_depth = "8";
+                    pixel_phase = "";
+                    readout_orientation = "0";
+                    line_length = "1920";
+                    inherent_gain = "1";
+                    pix_clk_hz = "300000000";
+                    lane_polarity = "0";
+
+                    gain_factor = "1";
+                    framerate_factor = "1000000";
+                    exposure_factor = "1000000";
+                    min_gain_val = "1";    /* Min Raw gain */
+                    max_gain_val = "256"; /* Max Raw gain */
+                    step_gain_val = "1";
+                    default_gain = "1"; /* 1.00x */
+                    min_hdr_ratio = "1";
+                    max_hdr_ratio = "1";
+                    min_framerate = "5000000";
+                    max_framerate = "100000000";
+                    step_framerate = "1000000";
+                    default_framerate = "100000000"; /* 100.0 fps */
+                    min_exp_time = "5"; /* us */
+                    max_exp_time = "200000"; /* us */
+                    step_exp_time = "1";
+                    default_exp_time = "9180"; /* us */
+                    embedded_metadata_height = "0";
+                };
+
+                mode11 { /* TOPAZ2M_MODE_1920x800_130FPS_RAW8 */
+                    mclk_khz = "50000";
+                    num_lanes = "2";
+                    tegra_sinterface = "serial_c";
+                    phy_mode = "DPHY";
+                    discontinuous_clk = "no";
+                    dpcm_enable = "false";
+                    cil_settletime = "0";
+                    active_w = "1920";
+                    active_h = "800";
+                    mode_type = "grey";
+                    csi_pixel_bit_depth = "8";
+                    pixel_phase = "";
+                    readout_orientation = "0";
+                    line_length = "1920";
+                    inherent_gain = "1";
+                    pix_clk_hz = "300000000";
+                    lane_polarity = "0";
+
+                    gain_factor = "1";
+                    framerate_factor = "1000000";
+                    exposure_factor = "1000000";
+                    min_gain_val = "1";    /* Min Raw gain */
+                    max_gain_val = "256"; /* Max Raw gain */
+                    step_gain_val = "1";
+                    default_gain = "1"; /* 1.00x */
+                    min_hdr_ratio = "1";
+                    max_hdr_ratio = "1";
+                    min_framerate = "5000000";
+                    max_framerate = "130000000";
+                    step_framerate = "1000000";
+                    default_framerate = "130000000"; /* 130.0 fps */
+                    min_exp_time = "5"; /* us */
+                    max_exp_time = "200000"; /* us */
+                    step_exp_time = "1";
+                    default_exp_time = "6800"; /* us */
+                    embedded_metadata_height = "0";
+                };
+
+                ports {
+                    #address-cells = <1>;
+                    #size-cells = <0>;
+
+                    port@0 {
+                        reg = <0>;
+                        topaz2m_out1: endpoint {
+                            port-index = <2>;
+                            bus-width = <2>;
+                            remote-endpoint = <&topaz2m_csi_in1>;
+                        };
+                    };
+                };
+            };
+        };
+    };
+
+    gpio@6000d000 {
+        camera-control-output {
+            gpio-hog;
+            output-low;
+            gpios = < CAM0_PWDN 0 >;
+            label = "cam0-pwdn";
+        };
+    };
+
+    gpio@6000d000 {
+        camera-control-output {
+            gpio-hog;
+            output-low;
+            gpios = < CAM1_PWDN 0 >;
+            label = "cam1-pwdn";
+        };
+    };
+};
+
+/ {
+    tegra-camera-platform {
+        compatible = "nvidia, tegra-camera-platform";
+        num_csi_lanes = <4>;
+        max_lane_speed = <1500000>;
+        min_bits_per_pixel = <8>;
+        vi_peak_byte_per_pixel = <2>;
+        vi_bw_margin_pct = <25>;
+        max_pixel_rate = <7500000>;
+        isp_peak_byte_per_pixel = <5>;
+        isp_bw_margin_pct = <25>;
+
+        modules {
+            module0 {
+                badge = "topaz2m_front_PM23020";
+                position = "front";
+                orientation = "1";
+                status = "okay";
+                drivernode0 {
+                    pcl_id = "v4l2_sensor";
+                    devname = "topaz2m 9-0010";
+                    proc-device-tree = "/proc/device-tree/cam_i2cmux/i2c@0/topaz2m_b@10";
+                    status = "okay";
+                };
+            };
+
+            module1 {
+                badge = "topaz2m_rear_PM23020";
+                position = "rear";
+                orientation = "0";
+                status = "okay";
+                drivernode0 {
+                    pcl_id = "v4l2_sensor";
+                    devname = "topaz2m 10-0010";
+                    proc-device-tree = "/proc/device-tree/cam_i2cmux/i2c@1/topaz2m_c@10";
+                    status = "okay";
+                };
+            };
+        };
+    };
+};
diff --git a/hardware/nvidia/platform/t23x/p3768/kernel-dts/cvb/tegra234-p3509-a02.dtsi b/hardware/nvidia/platform/t23x/p3768/kernel-dts/cvb/tegra234-p3509-a02.dtsi
index 2fa67db63..5fcf24d98 100644
--- a/hardware/nvidia/platform/t23x/p3768/kernel-dts/cvb/tegra234-p3509-a02.dtsi
+++ b/hardware/nvidia/platform/t23x/p3768/kernel-dts/cvb/tegra234-p3509-a02.dtsi
@@ -16,8 +16,7 @@
 #include "tegra234-p3509-a02-pcie.dtsi"
 #include "tegra234-p3509-a02-fixed-regulator.dtsi"
 #include "tegra234-p3509-audio.dtsi"
-#include "tegra234-p3768-camera-rbpcv3-imx477.dtsi"
-#include "tegra234-p3768-camera-rbpcv2-imx219.dtsi"
+#include "tegra234-camera-topaz2m.dtsi"
 
 / {
 	gpio-keys {
diff --git a/hardware/nvidia/platform/t23x/p3768/kernel-dts/cvb/tegra234-p3768-0000-a0.dtsi b/hardware/nvidia/platform/t23x/p3768/kernel-dts/cvb/tegra234-p3768-0000-a0.dtsi
index 95d737541..18f240ca5 100644
--- a/hardware/nvidia/platform/t23x/p3768/kernel-dts/cvb/tegra234-p3768-0000-a0.dtsi
+++ b/hardware/nvidia/platform/t23x/p3768/kernel-dts/cvb/tegra234-p3768-0000-a0.dtsi
@@ -16,8 +16,7 @@
 #include "tegra234-p3768-0000-a0-pcie.dtsi"
 #include "tegra234-p3768-0000-a0-fixed-regulator.dtsi"
 #include "tegra234-p3768-audio.dtsi"
-#include "tegra234-p3768-camera-rbpcv3-imx477.dtsi"
-#include "tegra234-p3768-camera-rbpcv2-imx219.dtsi"
+#include "tegra234-camera-topaz2m.dtsi"
 
 / {
 	gpio-keys {
diff --git a/kernel/kernel-5.10/arch/arm64/configs/defconfig b/kernel/kernel-5.10/arch/arm64/configs/defconfig
index ce9f3e0a7..0ec8207b5 100644
--- a/kernel/kernel-5.10/arch/arm64/configs/defconfig
+++ b/kernel/kernel-5.10/arch/arm64/configs/defconfig
@@ -884,7 +884,7 @@ CONFIG_VIDEO_CDI=m
 CONFIG_V4L_TEST_DRIVERS=y
 CONFIG_VIDEO_ECAM=m
 CONFIG_NV_VIDEO_IMX185=m
-CONFIG_NV_VIDEO_IMX219=m
+CONFIG_NV_VIDEO_TOPAZ2M=y
 CONFIG_NV_VIDEO_IMX477=m
 CONFIG_NV_VIDEO_IMX268=m
 CONFIG_NV_VIDEO_IMX274=m
diff --git a/kernel/nvidia/drivers/media/i2c/Kconfig b/kernel/nvidia/drivers/media/i2c/Kconfig
index 5ec3c683c..fa540c014 100644
--- a/kernel/nvidia/drivers/media/i2c/Kconfig
+++ b/kernel/nvidia/drivers/media/i2c/Kconfig
@@ -22,6 +22,15 @@ config NV_VIDEO_IMX477
 	  To compile this driver as a module, choose M here: the module
 	  will be called imx477.
 
+config NV_VIDEO_TOPAZ2M
+        tristate "TOPAZ2M camera sensor support"
+	depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
+	help
+	  This driver supports Topaz2M camera sensor from Teledyne
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called topaz2m.
+
 config VIDEO_ECAM
         tristate "ECAM camera sensor support"
         depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
diff --git a/kernel/nvidia/drivers/media/i2c/Makefile b/kernel/nvidia/drivers/media/i2c/Makefile
index c4708d8c7..6a5995bb1 100644
--- a/kernel/nvidia/drivers/media/i2c/Makefile
+++ b/kernel/nvidia/drivers/media/i2c/Makefile
@@ -6,6 +6,7 @@ ccflags-y += -I$(srctree)/drivers/video/tegra/camera
 obj-$(CONFIG_NV_VIDEO_IMX185) += nv_imx185.o
 obj-$(CONFIG_NV_VIDEO_IMX185) += nv_imx185_v1.o
 obj-$(CONFIG_NV_VIDEO_IMX477) += nv_imx477.o
+obj-$(CONFIG_NV_VIDEO_TOPAZ2M) += topaz2m.o
 obj-$(CONFIG_NV_VIDEO_IMX219) += nv_imx219.o
 obj-$(CONFIG_NV_VIDEO_IMX268) += nv_imx268.o
 obj-$(CONFIG_NV_VIDEO_IMX274) += nv_imx274.o
diff --git a/kernel/nvidia/drivers/media/i2c/topaz2m.c b/kernel/nvidia/drivers/media/i2c/topaz2m.c
new file mode 100644
index 000000000..5b203a65b
--- /dev/null
+++ b/kernel/nvidia/drivers/media/i2c/topaz2m.c
@@ -0,0 +1,3072 @@
+/*
+ * topaz2m.c - topaz2m sensor driver
+ *
+ * Copyright (c) 2024, RidgeRun, LLC.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/gpio.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <linux/seq_file.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+
+#include <media/tegra_v4l2_camera.h>
+#include <media/tegracam_core.h>
+
+#include "topaz2m_mode_tbls.h"
+
+#define TOPAZ2M_SENSOR_NAME                   "topaz2m"
+#define TOPAZ2M_EEPROM_NAME                   "topaz2m_eeprom"
+#define TOPAZ2M_TLENS_NAME                    "topaz2m_tlens"
+#define TOPAZ2M_TEMP_NAME                     "topaz2m_temperature_sensor"
+#define TOPAZ2M_VERSION                       "0.1.0"
+
+/* Chip ID is made up of 3 parts:
+ * 4 bits Chip family Topaz (MSB)
+ * 8 bits Chip part number
+ * 4 bits Sensor revision (LSB)
+ *
+ * Chip family Topaz section has to be 8 for Topaz sensor
+ * Chip part number section bit 0 has to be 1 for B&W and 0 for Color sensor
+ * Due to this, mask F010 is applied to check the Chip ID
+ */
+#define TOPAZ2M_SENSOR_ID                     0x8000
+#define TOPAZ2M_MODEL_ID_MASK                 0xF000
+#define TOPAZ2M_MODEL_ID_ADDR                 0x7F
+
+#define TOPAZ2M_REG_8_MSB_MASK                0xFF00
+#define TOPAZ2M_REG_8_MSB_SHIFT               8
+#define TOPAZ2M_REG_8_LSB_MASK                0x00FF
+#define TOPAZ2M_REG_16_MASK                   0xFFFF
+
+#define TOPAZ2M_TP_MODE_DISABLED              0
+#define TOPAZ2M_TP_MODE_FRONT                 1
+#define TOPAZ2M_TP_MODE_REAR                  2
+
+#define TOPAZ2M_MODULE_RESOLUTION_1_MP        0x0150
+#define TOPAZ2M_MODULE_RESOLUTION_2_MP        0x0200
+#define TOPAZ2M_MODULE_RESOLUTION_3_MP        0x0320
+#define TOPAZ2M_MODULE_RESOLUTION_5_MP        0x0500
+
+#define TOPAZ2M_MODULE_RESOLUTION_DEFAULT_VAL 1
+#define TOPAZ2M_MODULE_RESOLUTION_1_MP_VAL    1
+#define TOPAZ2M_MODULE_RESOLUTION_2_MP_VAL    2
+#define TOPAZ2M_MODULE_RESOLUTION_3_MP_VAL    3
+#define TOPAZ2M_MODULE_RESOLUTION_5_MP_VAL    5
+
+#define TOPAZ2M_MODULE_OPT_NO_LENS            0x0000
+#define TOPAZ2M_MODULE_OPT_FIXED              0x0100
+#define TOPAZ2M_MODULE_OPT_AUTO               0x0200
+
+#define TOPAZ2M_MODULE_OPT_DEFAULT_VAL        0
+#define TOPAZ2M_MODULE_OPT_NO_LENS_VAL        0
+#define TOPAZ2M_MODULE_OPT_FIXED_VAL          1
+#define TOPAZ2M_MODULE_OPT_AUTO_VAL           2
+
+#define TOPAZ2M_IS_COLOR_TRUE                 0x1000
+#define TOPAZ2M_IS_COLOR_TRUE_VAL             1
+#define TOPAZ2M_IS_COLOR_FALSE_VAL            0
+
+#define TOPAZ2M_IS_MULTIFOCUS_TRUE            0x0200
+#define TOPAZ2M_IS_MULTIFOCUS_TRUE_VAL        1
+#define TOPAZ2M_IS_MULTIFOCUS_FALSE_VAL       0
+
+#define TOPAZ2M_TLENS_ENABLE_VAL              0x01
+#define TOPAZ2M_TLENS_WARMUP_DAC_HIGH_VAL     732ll
+#define TOPAZ2M_TLENS_WARMUP_DAC_LOW_VAL      0ll
+#define TOPAZ2M_TLENS_WARMUP_DELAY_MS         10
+
+static s64 topaz2m_tlens_warmup_table[] = {
+    TOPAZ2M_TLENS_WARMUP_DAC_LOW_VAL,
+    TOPAZ2M_TLENS_WARMUP_DAC_HIGH_VAL,
+    TOPAZ2M_TLENS_WARMUP_DAC_LOW_VAL,
+    TOPAZ2M_TLENS_WARMUP_DAC_HIGH_VAL,
+    TOPAZ2M_TLENS_WARMUP_DAC_LOW_VAL,
+};
+
+typedef enum {
+	TOPAZ2M_FLASH_DELAY_ON = 0,
+	TOPAZ2M_FLASH_DELAY_OFF,
+} topaz2m_flash_delay_type;
+
+typedef enum {
+    TOPAZ2M_TP_DISABLED = 0,
+    TOPAZ2M_TP_FRONT_D,
+    TOPAZ2M_TP_REAR_DF,
+    TOPAZ2M_TP_COLUMN_INCREMENT_F,
+    TOPAZ2M_TP_LINE_INCREMENT_F,
+    TOPAZ2M_TP_DIAGONAL_M,
+    TOPAZ2M_TP_COLUMN_INCREMENT_M,
+    TOPAZ2M_TP_LINE_INCREMENT_M,
+    TOPAZ2M_TP_UNIFORM_0,
+    TOPAZ2M_TP_UNIFORM_20,
+    TOPAZ2M_TP_UNIFORM_127,
+    TOPAZ2M_TP_UNIFORM_255,
+    TOPAZ2M_TP_UNIFORM_511,
+    TOPAZ2M_TP_UNIFORM_1023,
+    TOPAZ2M_TP_END, /* Keep this at the end */
+} topaz2m_test_pattern_id;
+
+typedef struct {
+    topaz2m_test_pattern_id id;
+    u16 mode;
+    u16 config_1;
+    u16 config_2;
+} topaz2m_test_pattern_config;
+
+static topaz2m_test_pattern_config topaz2m_test_pattern_table[] = {
+    {TOPAZ2M_TP_DISABLED,           TOPAZ2M_TP_MODE_DISABLED, 0x09,    0},
+    {TOPAZ2M_TP_FRONT_D,            TOPAZ2M_TP_MODE_FRONT,    0x09,    0},
+    {TOPAZ2M_TP_REAR_DF,            TOPAZ2M_TP_MODE_REAR,     0x09,    0},
+    {TOPAZ2M_TP_COLUMN_INCREMENT_F, TOPAZ2M_TP_MODE_REAR,     0x01,    0},
+    {TOPAZ2M_TP_LINE_INCREMENT_F,   TOPAZ2M_TP_MODE_REAR,     0x08,    0},
+    {TOPAZ2M_TP_DIAGONAL_M,         TOPAZ2M_TP_MODE_REAR,     0x49,    0},
+    {TOPAZ2M_TP_COLUMN_INCREMENT_M, TOPAZ2M_TP_MODE_REAR,     0x41,    0},
+    {TOPAZ2M_TP_LINE_INCREMENT_M,   TOPAZ2M_TP_MODE_REAR,     0x48,    0},
+    {TOPAZ2M_TP_UNIFORM_0,          TOPAZ2M_TP_MODE_REAR,     0x00,    0},
+    {TOPAZ2M_TP_UNIFORM_20,         TOPAZ2M_TP_MODE_REAR,     0x00,   20},
+    {TOPAZ2M_TP_UNIFORM_127,        TOPAZ2M_TP_MODE_REAR,     0x00,  127},
+    {TOPAZ2M_TP_UNIFORM_255,        TOPAZ2M_TP_MODE_REAR,     0x00,  255},
+    {TOPAZ2M_TP_UNIFORM_511,        TOPAZ2M_TP_MODE_REAR,     0x00,  511},
+    {TOPAZ2M_TP_UNIFORM_1023,       TOPAZ2M_TP_MODE_REAR,     0x00, 1023},
+};
+
+typedef enum {
+    TOPAZ2M_TRIG_OUT_FR_TR = 0,
+    TOPAZ2M_TRIG_OUT_TR_FR,
+    TOPAZ2M_TRIG_OUT_FR_A1,
+    TOPAZ2M_TRIG_OUT_A1_FR,
+    TOPAZ2M_TRIG_OUT_FD_A1,
+    TOPAZ2M_TRIG_OUT_A1_FD,
+    TOPAZ2M_TRIG_OUT_FR_A2,
+    TOPAZ2M_TRIG_OUT_A2_FR,
+    TOPAZ2M_TRIG_OUT_FD_A2,
+    TOPAZ2M_TRIG_OUT_A2_FD,
+    TOPAZ2M_TRIG_OUT_END, /* Keep this at the end */
+} topaz2m_trigger_out_id;
+
+typedef struct {
+    topaz2m_trigger_out_id id;
+    u16 flash_sel_on_trig;
+    u16 aimer_mode;
+    u16 trig_out_sel;
+} topaz2m_trigger_out_config;
+
+static topaz2m_trigger_out_config topaz2m_trigger_out_table[] = {
+    {TOPAZ2M_TRIG_OUT_FR_TR, 0, 2, 0x0010},
+    {TOPAZ2M_TRIG_OUT_TR_FR, 0, 2, 0x1000},
+    {TOPAZ2M_TRIG_OUT_FR_A1, 0, 1, 0x0110},
+    {TOPAZ2M_TRIG_OUT_A1_FR, 0, 1, 0x1001},
+    {TOPAZ2M_TRIG_OUT_FD_A1, 1, 1, 0x0100},
+    {TOPAZ2M_TRIG_OUT_A1_FD, 1, 1, 0x0001},
+    {TOPAZ2M_TRIG_OUT_FR_A2, 0, 2, 0x0110},
+    {TOPAZ2M_TRIG_OUT_A2_FR, 0, 2, 0x1001},
+    {TOPAZ2M_TRIG_OUT_FD_A2, 1, 2, 0x0100},
+    {TOPAZ2M_TRIG_OUT_A2_FD, 1, 2, 0x0001},
+};
+
+static const struct of_device_id topaz2m_of_match[] = {
+    {
+     .compatible = "teledyne,topaz2m",
+     },
+    {},
+};
+
+MODULE_DEVICE_TABLE(of, topaz2m_of_match);
+
+static const u32 ctrl_cid_list[] = {
+    TEGRA_CAMERA_CID_GAIN,
+    TEGRA_CAMERA_CID_EXPOSURE,
+    TEGRA_CAMERA_CID_FRAME_RATE,
+    TEGRA_CAMERA_CID_SENSOR_MODE_ID,
+    TEGRA_CAMERA_CID_ANA_GAIN,
+    TEGRA_CAMERA_CID_DIG_GAIN,
+    TEGRA_CAMERA_CID_TEST_PATTERN,
+    TEGRA_CAMERA_CID_FLIP,
+    TEGRA_CAMERA_CID_COLOR_GAIN_B,
+    TEGRA_CAMERA_CID_COLOR_GAIN_G,
+    TEGRA_CAMERA_CID_COLOR_GAIN_R,
+    TEGRA_CAMERA_CID_COLOR_OFFSET_B,
+    TEGRA_CAMERA_CID_COLOR_OFFSET_G,
+    TEGRA_CAMERA_CID_COLOR_OFFSET_R,
+    TEGRA_CAMERA_CID_TRIGGER_OUTPUT,
+    TEGRA_CAMERA_CID_FLASH_DELAY_ON,
+    TEGRA_CAMERA_CID_FLASH_DELAY_OFF,
+    TEGRA_CAMERA_CID_IMAGE_OFFSET,
+    TEGRA_CAMERA_CID_MODULE_RESOLUTION,
+    TEGRA_CAMERA_CID_MODULE_OPTION,
+    TEGRA_CAMERA_CID_IS_COLOR,
+    TEGRA_CAMERA_CID_IS_MULTIFOCUS,
+    TEGRA_CAMERA_CID_WRITE_FOCUS_DAC,
+    TEGRA_CAMERA_CID_READ_FOCUS_DAC,
+    TEGRA_CAMERA_CID_MODULE_TEMPERATURE,
+    TEGRA_CAMERA_CID_SENSOR_TEMPERATURE,
+    TEGRA_CAMERA_CID_TEMPERATURE_RANGE,
+};
+
+struct subdev_info {
+    struct i2c_client *client;
+    struct i2c_adapter *adapter;
+    struct i2c_board_info board_info;
+    struct regmap *regmap;
+};
+
+struct topaz2m {
+    struct i2c_client *i2c_client;
+    struct v4l2_subdev *subdev;
+    u32 frame_length;
+    struct camera_common_data *s_data;
+    struct tegracam_device *tc_dev;
+    topaz2m_reg **mode_table;
+    struct subdev_info eeprom;
+    struct subdev_info tlens;
+    struct subdev_info temp;
+    bool color_enabled;
+    bool is_1M5;
+    bool tlens_enabled;
+    s64 focus_dac_value;
+    bool is_streaming;
+    bool temp_enabled;
+};
+
+static const struct regmap_config sensor_regmap_config = {
+    .reg_bits = 8,
+    .val_bits = 16,
+    .cache_type = REGCACHE_RBTREE,
+    .use_single_read = true,
+};
+
+static const struct regmap_config eeprom_regmap_config = {
+    .reg_bits = 16,
+    .val_bits = 8,
+    .cache_type = REGCACHE_RBTREE,
+    .use_single_read = true,
+};
+
+static const struct regmap_config tlens_regmap_config = {
+    .reg_bits = 8,
+    .val_bits = 8,
+    .cache_type = REGCACHE_RBTREE,
+    .use_single_read = true,
+};
+
+static const struct regmap_config temp_regmap_config = {
+    .reg_bits = 8,
+    .val_bits = 8,
+    .cache_type = REGCACHE_RBTREE,
+    .use_single_read = true,
+};
+
+static inline int topaz2m_read_reg(struct camera_common_data *s_data,
+                   u8 addr, u16 *val)
+{
+    int err = 0;
+    u32 reg_val = 0;
+
+    if (!s_data | !val) {
+        pr_err("%s:%d Either s_data or val is null", __func__, __LINE__);
+        err = -EINVAL;
+        goto exit;
+    }
+
+    err = regmap_read(s_data->regmap, addr, &reg_val);
+
+    if (err) {
+        pr_err("%s: %d", __func__, err);
+        goto exit;
+    }
+    *val = reg_val & TOPAZ2M_REG_16_MASK;
+
+exit:
+    return err;
+}
+
+static int topaz2m_write_reg(struct camera_common_data *s_data,
+                 u8 addr, u16 val)
+{
+    int err = 0;
+
+    if (!s_data) {
+        pr_err("%s:%d s_data is null", __func__, __LINE__);
+        err = -EINVAL;
+        goto exit;
+    }
+
+    err = regmap_write(s_data->regmap, addr, val);
+
+    if (err)
+        dev_err(s_data->dev, "%s: i2c write failed, 0x%x = %x",
+            __func__, addr, val);
+
+exit:
+    return err;
+}
+
+static inline int topaz2m_eeprom_read_reg(struct topaz2m *priv, u16 addr,
+                        unsigned int *val) {
+    int err = 0;
+
+    if (!priv | !val) {
+        pr_err("%s:%d Either priv or val is null", __func__, __LINE__);
+        err = -EINVAL;
+        goto exit;
+    }
+
+    err = regmap_read(priv->eeprom.regmap, addr, val);
+
+    if (err) {
+        pr_err("%s: eeprom regmap read failed: %d", __func__, err);
+        goto exit;
+    }
+
+exit:
+    return err;
+}
+
+static inline int topaz2m_eeprom_read_word(struct topaz2m *priv, u16 addr,
+                        unsigned int *val) {
+    unsigned int reg_val_msb = 0;
+    unsigned int reg_val_lsb = 0;
+    int err = 0;
+
+    if (!priv | !val) {
+        pr_err("%s:%d Either priv or val is null", __func__, __LINE__);
+        err = -EINVAL;
+        goto exit;
+    }
+
+    err = topaz2m_eeprom_read_reg(priv, addr, &reg_val_msb);
+    if (err) {
+        pr_err("%s: eeprom word msb read failed: %d", __func__, err);
+        goto exit;
+    }
+
+    err = topaz2m_eeprom_read_reg(priv, addr + 1, &reg_val_lsb);
+    if (err) {
+        pr_err("%s: eeprom word lsb read failed: %d", __func__, err);
+        goto exit;
+    }
+
+    *val = 0;
+    *val = (reg_val_msb << TOPAZ2M_REG_8_MSB_SHIFT) | reg_val_lsb;
+
+exit:
+    return err;
+}
+
+static inline int topaz2m_eeprom_write_reg(struct topaz2m *priv, u16 addr,
+                        u8 val) {
+    int err = 0;
+    struct camera_common_data *s_data = NULL;
+
+    if (!priv) {
+        pr_err("%s:%d priv is null", __func__, __LINE__);
+        err = -EINVAL;
+        goto exit;
+    }
+
+    s_data = priv->s_data;
+
+    err = regmap_write(priv->eeprom.regmap, addr, val);
+
+    if (err) {
+        dev_err(s_data->dev, "%s: eeprom regmap write failed, 0x%x = %x",
+            __func__, addr, val);
+        goto exit;
+    }
+
+exit:
+    return err;
+}
+
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+
+static int topaz2m_eeprom_g_register(struct v4l2_subdev *sd,
+                        struct v4l2_dbg_register *reg) {
+    int err = 0;
+    struct camera_common_data *s_data = NULL;
+    struct topaz2m *priv = NULL;
+    u16 reg_addr = 0;
+    unsigned int reg_val = 0;
+
+    if (!sd | !reg) {
+        pr_err("%s:%d Either subdevice or register is null", __func__, __LINE__);
+        err = -EINVAL;
+        goto exit;
+    }
+
+    s_data = container_of(sd, struct camera_common_data, subdev);
+    priv = (struct topaz2m *)s_data->priv;
+
+    reg_addr = reg->reg & TOPAZ2M_REG_16_MASK;
+
+    err = topaz2m_eeprom_read_reg(priv, reg_addr, &reg_val);
+    if (err) {
+        dev_err(s_data->dev, "%s: eeprom read register, 0x%x = %x",
+            __func__, reg_addr, reg_val);
+        goto exit;
+    }
+
+    reg->size = 1;
+    reg->val = (u64)reg_val;
+
+exit:
+    return err;
+}
+
+static int topaz2m_eeprom_s_register(struct v4l2_subdev *sd,
+                        const struct v4l2_dbg_register *reg) {
+    int err = 0;
+    struct camera_common_data *s_data = NULL;
+    struct topaz2m *priv = NULL;
+    u16 reg_addr = 0;
+    unsigned int reg_val = 0;
+
+    if (!sd | !reg) {
+        pr_err("%s:%d Either subdevice or register is null", __func__, __LINE__);
+        err = -EINVAL;
+        goto exit;
+    }
+
+    s_data = container_of(sd, struct camera_common_data, subdev);
+    priv = (struct topaz2m *)s_data->priv;
+
+    reg_addr = reg->reg & TOPAZ2M_REG_16_MASK;
+    reg_val = reg->val & TOPAZ2M_REG_16_MASK;
+
+    err = topaz2m_eeprom_write_reg(priv, reg_addr, reg_val);
+    if (err) {
+        dev_err(s_data->dev, "%s: eeprom write register failed, 0x%x = %x",
+            __func__, reg_addr, reg_val);
+        goto exit;
+    }
+
+exit:
+    return err;
+}
+
+#endif /* CONFIG_VIDEO_ADV_DEBUG */
+
+static inline int topaz2m_tlens_read_reg(struct topaz2m *priv, u8 addr, u8 *val) {
+    int err = 0;
+    unsigned int reg_val = 0;
+
+    if (!priv | !val) {
+        pr_err("%s:%d Either priv or val is null", __func__, __LINE__);
+        err = -EINVAL;
+        goto exit;
+    }
+
+    if (!priv->tlens.regmap) {
+        dev_err(priv->s_data->dev, "%s: cannot read to tlens\n", __func__);
+        err = -EINVAL;
+        goto exit;
+    }
+
+    regcache_cache_bypass(priv->tlens.regmap, true);
+    err = regmap_read(priv->tlens.regmap, addr, &reg_val);
+    regcache_cache_bypass(priv->tlens.regmap, false);
+
+    if (err) {
+        dev_err(priv->s_data->dev, "%s: tlens regmap read failed: %d\n",
+            __func__, err);
+        goto exit;
+    }
+
+    /* This step truncates the register value to 8 bits */
+    *val = reg_val;
+
+exit:
+    return err;
+}
+
+static inline int topaz2m_tlens_write_reg(struct topaz2m *priv, u8 addr,
+                        u8 val) {
+    int err = 0;
+
+    if (!priv) {
+        pr_err("%s:%d priv is null", __func__, __LINE__);
+        err = -EINVAL;
+        goto exit;
+    }
+
+    if (!priv->tlens.regmap) {
+        dev_err(priv->s_data->dev, "%s: cannot write to tlens\n", __func__);
+        err = -EINVAL;
+        goto exit;
+    }
+
+    err = regmap_write(priv->tlens.regmap, addr, val);
+
+    if (err) {
+        dev_err(priv->s_data->dev, "%s: tlens regmap write failed, 0x%x = %x",
+            __func__, addr, val);
+        goto exit;
+    }
+
+exit:
+    return err;
+}
+
+static inline int topaz2m_temp_read_reg(struct topaz2m *priv, u8 addr, u8 *val) {
+    int err = 0;
+    unsigned int reg_val = 0;
+
+    if (!priv | !val) {
+        pr_err("%s:%d Either priv or val is null", __func__, __LINE__);
+        err = -EINVAL;
+        goto exit;
+    }
+
+    if (!priv->temp.regmap) {
+        dev_err(priv->s_data->dev, "%s: cannot read from temperature sensor\n", __func__);
+        err = -EINVAL;
+        goto exit;
+    }
+
+    regcache_cache_bypass(priv->temp.regmap, true);
+    err = regmap_read(priv->temp.regmap, addr, &reg_val);
+    regcache_cache_bypass(priv->temp.regmap, false);
+
+    if (err) {
+        dev_err(priv->s_data->dev, "%s: temperature sensor regmap read failed: %d\n",
+            __func__, err);
+        goto exit;
+    }
+
+    /* This step truncates the register value to 8 bits */
+    *val = reg_val;
+
+exit:
+    return err;
+}
+
+static inline int topaz2m_temp_write_reg(struct topaz2m *priv, u8 addr,
+                        u8 val) {
+    int err = 0;
+
+    if (!priv) {
+        pr_err("%s:%d priv is null", __func__, __LINE__);
+        err = -EINVAL;
+        goto exit;
+    }
+
+    if (!priv->temp.regmap) {
+        dev_err(priv->s_data->dev, "%s: cannot write to temperature sensor\n", __func__);
+        err = -EINVAL;
+        goto exit;
+    }
+
+    err = regmap_write(priv->temp.regmap, addr, val);
+
+    if (err) {
+        dev_err(priv->s_data->dev, "%s: temperature sensor regmap write failed, 0x%x = %x",
+            __func__, addr, val);
+        goto exit;
+    }
+
+exit:
+    return err;
+}
+
+static int topaz2m_write_pixel_timing_table(struct topaz2m *priv,
+                        const topaz2m_reg table[])
+{
+    struct camera_common_data *s_data = NULL;
+    u8 wait_ms_addr = TOPAZ2M_TABLE_WAIT_MS;
+    u8 end_addr = TOPAZ2M_TABLE_END;
+    u8 ram_offset_address = TOPAZ2M_RAM_OFFSET_REGISTER;
+    u16 offset_value = 0;
+    int err = 0;
+    const struct reg_8_16 *next = NULL;
+
+    if (!priv | !table) {
+        pr_err("%s:%d either priv or table is null", __func__, __LINE__);
+        err = -EINVAL;
+        goto exit;
+    }
+
+    s_data = priv->s_data;
+
+    for (next = table;; next++) {
+        /* Handle special address values */
+        if (next->addr == end_addr)
+            break;
+
+        if (next->addr == wait_ms_addr) {
+            msleep_range(next->val);
+            continue;
+        }
+
+        /* According to the Teledyne documentation
+         * The offset address (0x4f) is the offset from
+         * where data will be written, or read.
+         * First word address is 0x0000,
+         * last word address is 0x0097.
+         * Last word is reached when next->addr
+         * is equal to end_addr
+         */
+        err =
+            topaz2m_write_reg(s_data, ram_offset_address, offset_value);
+        if (err) {
+            dev_err(s_data->dev, "%s:%d", __func__, err);
+            goto exit;
+        }
+
+        /* The register 0x50 is used to
+         * write word (16bit)
+         * data in pixel timing RAM memory
+         * through a burst access
+         */
+        err = topaz2m_write_reg(s_data, next->addr, next->val);
+        if (err) {
+            dev_err(s_data->dev, "%s:%d", __func__, err);
+            goto exit;
+        }
+        offset_value++;
+    }
+
+exit:
+    return err;
+}
+
+static int topaz2m_write_table(struct topaz2m *priv, const topaz2m_reg table[])
+{
+    struct camera_common_data *s_data = NULL;
+    u8 wait_ms_addr = TOPAZ2M_TABLE_WAIT_MS;
+    u8 end_addr = TOPAZ2M_TABLE_END;
+    int err = 0;
+    const struct reg_8_16 *next = NULL;
+
+    if (!priv | !table) {
+        pr_err("%s:%d either priv or table is null", __func__, __LINE__);
+        err = -EINVAL;
+        goto exit;
+    }
+
+    s_data = priv->s_data;
+
+    for (next = table;; next++) {
+        /* Handle special address values */
+        if (next->addr == end_addr)
+            break;
+
+        if (next->addr == wait_ms_addr) {
+            msleep_range(next->val);
+            continue;
+        }
+
+        err = topaz2m_write_reg(s_data, next->addr, next->val);
+        if (err) {
+            dev_err(s_data->dev, "%s:%d", __func__, err);
+            goto exit;
+        }
+    }
+
+exit:
+    return err;
+}
+
+static int topaz2m_set_group_hold(struct tegracam_device *tc_dev, bool val)
+{
+    return 0;
+}
+
+static int topaz2m_set_gain(struct tegracam_device *tc_dev, s64 val)
+{
+    return 0;
+}
+
+static int topaz2m_set_frame_rate(struct tegracam_device *tc_dev, s64 val)
+{
+    struct camera_common_data *s_data = NULL;
+    struct device *dev = NULL;
+    const struct sensor_mode_properties *mode = NULL;
+    u32 master_clock_mega_hertz = 0;
+    u16 frame_rate_period = 0;
+    u16 line_length = 0;
+    u16 normal_val = 0;
+    int err = 0;
+
+    if (!tc_dev) {
+        pr_err("%s:%d tc_dev is null", __func__, __LINE__);
+        err = -EINVAL;
+        goto exit;
+    }
+
+    s_data = tc_dev->s_data;
+    dev = tc_dev->dev;
+    mode = &s_data->sensor_props.sensor_modes[s_data->mode_prop_idx];
+    master_clock_mega_hertz = mode->signal_properties.mclk_freq * 1000;
+
+    err = topaz2m_read_reg(s_data, TOPAZ2M_LINE_LENGTH_REG, &line_length);
+    if (err) {
+        dev_err(dev,
+            "%s: Could not read line length register 0x%02x. Read error.",
+            __func__, TOPAZ2M_LINE_LENGTH_REG);
+        goto exit;
+    }
+
+    /* The sensor frame rate is given by a parameter called frame rate period (Register 0x07)
+     * The real exposure time is given by Teledyne as follows:
+     * exposure = (height resolution * line length) / Master clock
+     * The frame rate can be seen as a maximum real exposure time as follows:
+     * (1 / FPS) = (frame rate period * line length) / Master Clock
+     * So, solve the equation for frame rate period:
+     * frame rate period = Master clock / (FPS * line length)
+     */
+
+    frame_rate_period =
+        ((unsigned long long)mode->control_properties.framerate_factor * master_clock_mega_hertz) /
+        ((unsigned long long)val * line_length);
+
+    normal_val = val / mode->control_properties.framerate_factor;
+
+    dev_dbg(dev,
+        "%s: val: %d [fps], frame_length: %u [lines]\n",
+        __func__, normal_val, frame_rate_period);
+
+    err =
+        topaz2m_write_reg(s_data, TOPAZ2M_FRAME_RATE_PERIOD_VALUE,
+                  frame_rate_period);
+    if (err) {
+        dev_err(dev,
+            "%s: Could not write new frame rate period value(%d). Write error.",
+            __func__, frame_rate_period);
+        goto exit;
+    }
+
+exit:
+    return err;
+}
+
+static int topaz2m_set_exposure(struct tegracam_device *tc_dev, s64 val)
+{
+    struct camera_common_data *s_data = NULL;
+    struct device *dev = NULL;
+    const struct sensor_mode_properties *mode = NULL;
+    u32 master_clock_mega_hertz = 0;
+    u16 frame_rate_period = 0;
+    u16 line_length = 0;
+    u64 exposure_time_base = 0;
+    u16 exposure_coarse_time = 0;
+    u16 exposure_fine_time = 0;
+    int err = 0;
+
+    if (!tc_dev) {
+        pr_err("%s:%d tc_dev is null", __func__, __LINE__);
+        err = -EINVAL;
+        goto exit;
+    }
+
+    s_data = tc_dev->s_data;
+    dev = tc_dev->dev;
+    mode = &s_data->sensor_props.sensor_modes[s_data->mode_prop_idx];
+    master_clock_mega_hertz = mode->signal_properties.mclk_freq * 1000;
+
+    err = topaz2m_read_reg(s_data, TOPAZ2M_LINE_LENGTH_REG, &line_length);
+    if (err) {
+        dev_err(dev,
+            "%s: Could not read line length register 0x%02x. Read error.",
+            __func__, TOPAZ2M_LINE_LENGTH_REG);
+        goto exit;
+    }
+
+    err =
+        topaz2m_read_reg(s_data, TOPAZ2M_FRAME_RATE_PERIOD_VALUE,
+                 &frame_rate_period);
+    if (err) {
+        dev_err(dev,
+            "%s: Could not read line length register 0x%02x. Read error.",
+            __func__, TOPAZ2M_FRAME_RATE_PERIOD_VALUE);
+        goto exit;
+    }
+
+    /* To calculate the exposure time, Teledyne provides the following steps:
+     * Convert input float in TIMEBASE unit (integer) : tint_timebase=tint_in * 1000000/TIMEBASE
+     * Calculate the coarse value (integer):
+     * tint_ll = tint_timebase / linelength  => write in register 0x0B
+     * Calculate the fine value (integer):
+     * tint_ck = tint_timebase – (tint_ll * line_length) => write in register 0x0C
+     */
+
+    exposure_time_base =
+        (val * master_clock_mega_hertz) /
+        (mode->control_properties.exposure_factor);
+
+    exposure_coarse_time = exposure_time_base / line_length;
+
+    exposure_fine_time =
+        exposure_time_base - (exposure_coarse_time * line_length);
+
+    if (exposure_fine_time >= line_length)
+        exposure_fine_time = line_length - 1;
+
+    dev_dbg(dev,
+        "%s: exposure_time: %lld [us], coarse_time: %d [lines], fine_time: %d [clock cycles] \n",
+        __func__, val, exposure_coarse_time, exposure_fine_time);
+
+    err =
+        topaz2m_write_reg(s_data, TOPAZ2M_EXPOSURE_COARSE_TIME_REG,
+                  exposure_coarse_time);
+    if (err) {
+        dev_err(dev,
+            "%s: Could not write new exposure coarse time value(%d). Write error.",
+            __func__, exposure_coarse_time);
+        goto exit;
+    }
+
+    err =
+        topaz2m_write_reg(s_data, TOPAZ2M_EXPOSURE_FINE_TIME_REG,
+                  exposure_fine_time);
+    if (err) {
+        dev_err(dev,
+            "%s: Could not write new exposure fine time value(%d). Write error.",
+            __func__, exposure_fine_time);
+        goto exit;
+    }
+
+exit:
+    return err;
+}
+
+static int topaz2m_set_analog_gain(struct tegracam_device *tc_dev, s64 val)
+{
+    struct device *dev = NULL;
+    struct camera_common_data *s_data = NULL;
+    int err = 0;
+
+    if (!tc_dev) {
+        pr_err("%s:%d tc_dev is null", __func__, __LINE__);
+        err = -EINVAL;
+        goto exit;
+    }
+
+    dev = tc_dev->dev;
+    s_data = tc_dev->s_data;
+
+    err = topaz2m_write_reg(s_data, TOPAZ2M_ANA_GAIN_ADDR, (u16)val);
+    if (err) {
+        dev_err(dev,
+            "%s: Could not write new gain value(%d). Write error.",
+            __func__, (u16)val);
+        goto exit;
+    }
+
+    dev_dbg(dev, "%s: Updated Analog Gain Register 0x%02x to: 0x%04x\n",
+        __func__, TOPAZ2M_ANA_GAIN_ADDR, (u16)val);
+
+exit:
+    return err;
+}
+
+static int topaz2m_set_digital_gain(struct tegracam_device *tc_dev, s64 val)
+{
+    struct device *dev = NULL;
+    struct camera_common_data *s_data = NULL;
+    u16 digital_gain = 0;
+    int err = 0;
+
+    if (!tc_dev) {
+        pr_err("%s:%d tc_dev is null", __func__, __LINE__);
+        err = -EINVAL;
+        goto exit;
+    }
+
+    dev = tc_dev->dev;
+    s_data = tc_dev->s_data;
+
+    /*
+     * The value indicated by the user is limited within the allowed range for
+     * the digital gain register
+     */
+
+    if (TOPAZ2M_DIG_GAIN_MAX < val) {
+        val = TOPAZ2M_DIG_GAIN_MAX;
+    }
+
+    if (TOPAZ2M_DIG_GAIN_MIN > val) {
+        val = TOPAZ2M_DIG_GAIN_MIN;
+    }
+
+    digital_gain = val;
+
+    err = topaz2m_write_reg(s_data, TOPAZ2M_DIG_GAIN_ADDR, digital_gain);
+    if (err) {
+        dev_err(dev,
+            "%s: Could not write new gain value(%d). Write error.",
+            __func__, digital_gain);
+        goto exit;
+    }
+
+    dev_dbg(dev, "%s: Updated digital Gain Register 0x%02x to: 0x%04x\n",
+        __func__, TOPAZ2M_DIG_GAIN_ADDR, digital_gain);
+
+exit:
+    return err;
+}
+
+static int topaz2m_set_test_pattern(struct tegracam_device *tc_dev, s64 val)
+{
+    struct device *dev = NULL;
+    struct camera_common_data *s_data = NULL;
+    u16 reg_val = 0;
+    u16 mode = 0;
+    u16 config_1 = 0;
+    u16 config_2 = 0;
+    int err = 0;
+
+    if (!tc_dev) {
+        pr_err("%s:%d tc_dev is null", __func__, __LINE__);
+        err = -EINVAL;
+        goto exit;
+    }
+
+    dev = tc_dev->dev;
+    s_data = tc_dev->s_data;
+
+    err = topaz2m_read_reg(s_data, TOPAZ2M_TEST_PATTERN_MODE_REG, &reg_val);
+    if (err) {
+        dev_err(dev,
+            "%s: error during test pattern register read (%d)\n",
+            __func__, err);
+        goto exit;
+    }
+
+    /* To set the test pattern 3 registers are changed.
+     * For the first register, only the 2 LSB are changed.
+     * These values are first reset before adding the new value
+     */
+
+    reg_val &= TOPAZ2M_TEST_PATTERN_MODE_MASK;
+
+    if (TOPAZ2M_TP_END <= val) {
+        val = 0;
+    }
+
+    mode = topaz2m_test_pattern_table[val].mode;
+    config_1 = topaz2m_test_pattern_table[val].config_1;
+    config_2 = topaz2m_test_pattern_table[val].config_2;
+
+    reg_val |= mode;
+
+    err = topaz2m_write_reg(s_data, TOPAZ2M_TEST_PATTERN_MODE_REG, reg_val);
+
+    if (err) {
+        dev_err(dev,
+            "%s: Could not write test pattern mode value(%d). Write error.",
+            __func__, reg_val);
+        goto exit;
+    }
+
+    dev_dbg(dev, "%s: Updated test pattern mode Register 0x%02x to: 0x%04x\n",
+        __func__, TOPAZ2M_TEST_PATTERN_MODE_REG, reg_val);
+
+    err = topaz2m_write_reg(s_data, TOPAZ2M_TEST_PATTERN_CONFIG_1_REG, config_1);
+
+    if (err) {
+        dev_err(dev,
+            "%s: Could not write test pattern config 1 value(%d). Write error.",
+            __func__, config_1);
+        goto exit;
+    }
+
+    dev_dbg(dev, "%s: Updated test pattern config 1 Register 0x%02x to: 0x%04x\n",
+        __func__, TOPAZ2M_TEST_PATTERN_CONFIG_1_REG, config_1);
+
+    err = topaz2m_write_reg(s_data, TOPAZ2M_TEST_PATTERN_CONFIG_2_REG, config_2);
+
+    if (err) {
+        dev_err(dev,
+            "%s: Could not write test pattern config 2 value(%d). Write error.",
+            __func__, config_2);
+        goto exit;
+    }
+
+    dev_dbg(dev, "%s: Updated test pattern config 2 Register 0x%02x to: 0x%04x\n",
+        __func__, TOPAZ2M_TEST_PATTERN_CONFIG_2_REG, config_2);
+
+exit:
+    return err;
+}
+
+static int topaz2m_set_flip(struct tegracam_device *tc_dev, s64 val)
+{
+    struct camera_common_data *s_data = NULL;
+    struct device *dev = NULL;
+    u16 reg_val = 0;
+    int err = 0;
+
+    if (!tc_dev) {
+        pr_err("%s:%d tc_dev is null", __func__, __LINE__);
+        err = -EINVAL;
+        goto exit;
+    }
+
+    s_data = tc_dev->s_data;
+    dev = tc_dev->dev;
+
+    err = topaz2m_read_reg(s_data, TOPAZ2M_ROI1_REG, &reg_val);
+    if (err) {
+        dev_err(dev,
+            "%s: error during test pattern register read (%d)\n",
+            __func__, err);
+        goto exit;
+    }
+
+    /* To set the flip, the two less significant bits
+     * of register 0x13 needs to be changed.
+     * So to perform this, two left shifting and
+     * two right shitfing can be camputed.
+     * After performing the above, the value compute by the user
+     * can be added. However, the test pattern bits can only have values
+     * between 0 and 11 (3 in decimal).
+     */
+
+    reg_val = (reg_val & 0xFFFC) + (val & 0x03);
+
+    err = topaz2m_write_reg(s_data, TOPAZ2M_ROI1_REG, reg_val);
+
+    if (err) {
+        dev_err(dev,
+            "%s: Could not write flip value(%d). Write error.",
+            __func__, reg_val);
+        goto exit;
+    }
+
+    dev_dbg(dev, "%s: Updated Flip Register 0x%02x to: 0x%04x\n", __func__,
+        TOPAZ2M_ROI1_REG, reg_val);
+
+exit:
+    return err;
+}
+
+static int topaz2m_set_color_gain_b(struct tegracam_device *tc_dev, s64 val)
+{
+    struct camera_common_data *s_data = NULL;
+    struct device *dev = NULL;
+    struct topaz2m *priv = NULL;
+    u16 reg_val = 0;
+    int err = 0;
+
+    if (!tc_dev) {
+        pr_err("%s:%d tc_dev is null", __func__, __LINE__);
+        err = -EINVAL;
+        goto exit;
+    }
+
+    s_data = tc_dev->s_data;
+    dev = tc_dev->dev;
+    priv = (struct topaz2m *)tegracam_get_privdata(tc_dev);
+
+    if (!priv->color_enabled) {
+        dev_info(dev,
+            "%s: Cannot set color gain b, color support is disabled",
+            __func__);
+        /* This method should exit successfully since it is called during driver
+         * setup regardless of whether the sensor supports it or not
+         */
+        err = 0;
+        goto exit;
+    }
+
+    if (TOPAZ2M_COLOR_GAIN_MAX < val) {
+        val = TOPAZ2M_COLOR_GAIN_MAX;
+    }
+
+    if (TOPAZ2M_COLOR_GAIN_MIN > val) {
+        val = TOPAZ2M_COLOR_GAIN_MIN;
+    }
+
+    reg_val = val;
+
+    err = topaz2m_write_reg(s_data, TOPAZ2M_COLOR_GAIN_B_REG, reg_val);
+
+    if (err) {
+        dev_err(dev,
+            "%s: Could not write color gain b value(%d). Write error.",
+            __func__, reg_val);
+        goto exit;
+    }
+
+    dev_dbg(dev, "%s: Updated Color Gain B Register 0x%02x to: 0x%04x\n", __func__,
+        TOPAZ2M_COLOR_GAIN_B_REG, reg_val);
+
+exit:
+    return err;
+}
+
+static int topaz2m_set_color_gain_g(struct tegracam_device *tc_dev, s64 val)
+{
+    struct camera_common_data *s_data = NULL;
+    struct device *dev = NULL;
+    struct topaz2m *priv = NULL;
+    u16 reg_val = 0;
+    int err = 0;
+
+    if (!tc_dev) {
+        pr_err("%s:%d tc_dev is null", __func__, __LINE__);
+        err = -EINVAL;
+        goto exit;
+    }
+
+    s_data = tc_dev->s_data;
+    dev = tc_dev->dev;
+    priv = (struct topaz2m *)tegracam_get_privdata(tc_dev);
+
+    if (!priv->color_enabled) {
+        dev_info(dev,
+            "%s: Cannot set color gain g, color support is disabled",
+            __func__);
+        /* This method should exit successfully since it is called during driver
+         * setup regardless of whether the sensor supports it or not
+         */
+        err = 0;
+        goto exit;
+    }
+
+    if (TOPAZ2M_COLOR_GAIN_MAX < val) {
+        val = TOPAZ2M_COLOR_GAIN_MAX;
+    }
+
+    if (TOPAZ2M_COLOR_GAIN_MIN > val) {
+        val = TOPAZ2M_COLOR_GAIN_MIN;
+    }
+
+    reg_val = val;
+
+    /* There are 2 green color gains according to the two green colors in the
+     * sensor bayer pattern. However, a single green control is implemented that
+     * sets the same gain for both green colors.
+     */
+
+    err = topaz2m_write_reg(s_data, TOPAZ2M_COLOR_GAIN_GB_REG, reg_val);
+
+    if (err) {
+        dev_err(dev,
+            "%s: Could not write color gain gb value(%d). Write error.",
+            __func__, reg_val);
+        goto exit;
+    }
+
+    dev_dbg(dev, "%s: Updated Color Gain GB Register 0x%02x to: 0x%04x\n", __func__,
+        TOPAZ2M_COLOR_GAIN_GB_REG, reg_val);
+
+    err = topaz2m_write_reg(s_data, TOPAZ2M_COLOR_GAIN_GR_REG, reg_val);
+
+    if (err) {
+        dev_err(dev,
+            "%s: Could not write color gain gr value(%d). Write error.",
+            __func__, reg_val);
+        goto exit;
+    }
+
+    dev_dbg(dev, "%s: Updated Color Gain GR Register 0x%02x to: 0x%04x\n", __func__,
+        TOPAZ2M_COLOR_GAIN_GR_REG, reg_val);
+
+exit:
+    return err;
+}
+
+static int topaz2m_set_color_gain_r(struct tegracam_device *tc_dev, s64 val)
+{
+    struct camera_common_data *s_data = NULL;
+    struct device *dev = NULL;
+    struct topaz2m *priv = NULL;
+    u16 reg_val = 0;
+    int err = 0;
+
+    if (!tc_dev) {
+        pr_err("%s:%d tc_dev is null", __func__, __LINE__);
+        err = -EINVAL;
+        goto exit;
+    }
+
+    s_data = tc_dev->s_data;
+    dev = tc_dev->dev;
+    priv = (struct topaz2m *)tegracam_get_privdata(tc_dev);
+
+    if (!priv->color_enabled) {
+        dev_info(dev,
+            "%s: Cannot set color gain r, color support is disabled",
+            __func__);
+        /* This method should exit successfully since it is called during driver
+         * setup regardless of whether the sensor supports it or not
+         */
+        err = 0;
+        goto exit;
+    }
+
+    if (TOPAZ2M_COLOR_GAIN_MAX < val) {
+        val = TOPAZ2M_COLOR_GAIN_MAX;
+    }
+
+    if (TOPAZ2M_COLOR_GAIN_MIN > val) {
+        val = TOPAZ2M_COLOR_GAIN_MIN;
+    }
+
+    reg_val = val;
+
+    err = topaz2m_write_reg(s_data, TOPAZ2M_COLOR_GAIN_R_REG, reg_val);
+
+    if (err) {
+        dev_err(dev,
+            "%s: Could not write color gain r value(%d). Write error.",
+            __func__, reg_val);
+        goto exit;
+    }
+
+    dev_dbg(dev, "%s: Updated Color Gain R Register 0x%02x to: 0x%04x\n", __func__,
+        TOPAZ2M_COLOR_GAIN_R_REG, reg_val);
+
+exit:
+    return err;
+}
+
+static int topaz2m_set_color_offset_b(struct tegracam_device *tc_dev, s64 val)
+{
+    struct camera_common_data *s_data = NULL;
+    struct device *dev = NULL;
+    struct topaz2m *priv = NULL;
+    u16 reg_val = 0;
+    int err = 0;
+
+    if (!tc_dev) {
+        pr_err("%s:%d tc_dev is null", __func__, __LINE__);
+        err = -EINVAL;
+        goto exit;
+    }
+
+    s_data = tc_dev->s_data;
+    dev = tc_dev->dev;
+    priv = (struct topaz2m *)tegracam_get_privdata(tc_dev);
+
+    if (!priv->color_enabled) {
+        dev_info(dev,
+            "%s: Cannot set color offset b, color support is disabled",
+            __func__);
+        /* This method should exit successfully since it is called during driver
+         * setup regardless of whether the sensor supports it or not
+         */
+        err = 0;
+        goto exit;
+    }
+
+    err = topaz2m_read_reg(s_data, TOPAZ2M_COLOR_OFFSET_B_REG, &reg_val);
+    if (err) {
+        dev_err(dev,
+            "%s: error during color offset b register read (%d)\n",
+            __func__, err);
+        goto exit;
+    }
+
+    reg_val = (reg_val & TOPAZ2M_REG_8_MSB_MASK) | (val & TOPAZ2M_REG_8_LSB_MASK);
+
+    err = topaz2m_write_reg(s_data, TOPAZ2M_COLOR_OFFSET_B_REG, reg_val);
+
+    if (err) {
+        dev_err(dev,
+            "%s: Could not write color offset b value(%d). Write error.",
+            __func__, reg_val);
+        goto exit;
+    }
+
+    dev_dbg(dev, "%s: Updated Color Offset B Register 0x%02x to: 0x%04x\n", __func__,
+        TOPAZ2M_COLOR_OFFSET_B_REG, reg_val);
+
+exit:
+    return err;
+}
+
+static int topaz2m_set_color_offset_g(struct tegracam_device *tc_dev, s64 val)
+{
+    struct camera_common_data *s_data = NULL;
+    struct device *dev = NULL;
+    struct topaz2m *priv = NULL;
+    u16 gb_reg_val = 0;
+    u16 gr_reg_val = 0;
+    int err = 0;
+
+    if (!tc_dev) {
+        pr_err("%s:%d tc_dev is null", __func__, __LINE__);
+        err = -EINVAL;
+        goto exit;
+    }
+
+    s_data = tc_dev->s_data;
+    dev = tc_dev->dev;
+    priv = (struct topaz2m *)tegracam_get_privdata(tc_dev);
+
+    if (!priv->color_enabled) {
+        dev_info(dev,
+            "%s: Cannot set color offset g, color support is disabled",
+            __func__);
+        /* This method should exit successfully since it is called during driver
+         * setup regardless of whether the sensor supports it or not
+         */
+        err = 0;
+        goto exit;
+    }
+
+    err = topaz2m_read_reg(s_data, TOPAZ2M_COLOR_OFFSET_GB_REG, &gb_reg_val);
+    if (err) {
+        dev_err(dev,
+            "%s: error during color offset gb register read (%d)\n",
+            __func__, err);
+        goto exit;
+    }
+
+    err = topaz2m_read_reg(s_data, TOPAZ2M_COLOR_OFFSET_GR_REG, &gr_reg_val);
+    if (err) {
+        dev_err(dev,
+            "%s: error during color offset gr register read (%d)\n",
+            __func__, err);
+        goto exit;
+    }
+
+    /* There are 2 green color offsets according to the two green colors in the
+     * sensor bayer pattern. However, a single green control is implemented that
+     * sets the same offset for both green colors.
+     */
+
+    gb_reg_val = (gb_reg_val & TOPAZ2M_REG_8_LSB_MASK) | (val << TOPAZ2M_GREEN_OFFSET_SHIFT);
+    gr_reg_val = (gr_reg_val & TOPAZ2M_REG_8_LSB_MASK) | (val << TOPAZ2M_GREEN_OFFSET_SHIFT);
+
+    err = topaz2m_write_reg(s_data, TOPAZ2M_COLOR_OFFSET_GB_REG, gb_reg_val);
+
+    if (err) {
+        dev_err(dev,
+            "%s: Could not write color offset gb value(%d). Write error.",
+            __func__, gb_reg_val);
+        goto exit;
+    }
+
+    dev_dbg(dev, "%s: Updated Color Offset GB Register 0x%02x to: 0x%04x\n", __func__,
+        TOPAZ2M_COLOR_OFFSET_GB_REG, gb_reg_val);
+
+
+    err = topaz2m_write_reg(s_data, TOPAZ2M_COLOR_OFFSET_GR_REG, gr_reg_val);
+
+    if (err) {
+        dev_err(dev,
+            "%s: Could not write color offset gr value(%d). Write error.",
+            __func__, gr_reg_val);
+        goto exit;
+    }
+
+    dev_dbg(dev, "%s: Updated Color Offset GR Register 0x%02x to: 0x%04x\n", __func__,
+        TOPAZ2M_COLOR_OFFSET_GR_REG, gr_reg_val);
+
+exit:
+    return err;
+}
+
+static int topaz2m_set_color_offset_r(struct tegracam_device *tc_dev, s64 val)
+{
+    struct camera_common_data *s_data = NULL;
+    struct device *dev = NULL;
+    struct topaz2m *priv = NULL;
+    u16 reg_val = 0;
+    int err = 0;
+
+    if (!tc_dev) {
+        pr_err("%s:%d tc_dev is null", __func__, __LINE__);
+        err = -EINVAL;
+        goto exit;
+    }
+
+    s_data = tc_dev->s_data;
+    dev = tc_dev->dev;
+    priv = (struct topaz2m *)tegracam_get_privdata(tc_dev);
+
+    if (!priv->color_enabled) {
+        dev_info(dev,
+            "%s: Cannot set color offset r, color support is disabled",
+            __func__);
+        /* This method should exit successfully since it is called during driver
+         * setup regardless of whether the sensor supports it or not
+         */
+        err = 0;
+        goto exit;
+    }
+
+    err = topaz2m_read_reg(s_data, TOPAZ2M_COLOR_OFFSET_R_REG, &reg_val);
+    if (err) {
+        dev_err(dev,
+            "%s: error during color offset r register read (%d)\n",
+            __func__, err);
+        goto exit;
+    }
+
+    reg_val = (reg_val & TOPAZ2M_REG_8_MSB_MASK) | (val & TOPAZ2M_REG_8_LSB_MASK);
+
+    err = topaz2m_write_reg(s_data, TOPAZ2M_COLOR_OFFSET_R_REG, reg_val);
+
+    if (err) {
+        dev_err(dev,
+            "%s: Could not write color offset r value(%d). Write error.",
+            __func__, reg_val);
+        goto exit;
+    }
+
+    dev_dbg(dev, "%s: Updated Color Offset R Register 0x%02x to: 0x%04x\n", __func__,
+        TOPAZ2M_COLOR_OFFSET_R_REG, reg_val);
+
+exit:
+    return err;
+}
+
+static int topaz2m_set_trigger_output(struct tegracam_device *tc_dev, s64 val)
+{
+    struct camera_common_data *s_data = NULL;
+    struct device *dev = NULL;
+    u16 reg_val_flash_sel = 0;
+    u16 reg_val_aimer_mode = 0;
+    u16 flash_sel_on_trig = 0;
+    u16 aimer_mode = 0;
+    u16 trig_out_sel = 0;
+    int err = 0;
+
+    if (!tc_dev) {
+        pr_err("%s:%d tc_dev is null", __func__, __LINE__);
+        err = -EINVAL;
+        goto exit;
+    }
+
+    s_data = tc_dev->s_data;
+    dev = tc_dev->dev;
+
+    err = topaz2m_read_reg(s_data, TOPAZ2M_TRIG_OUT_FLASH_SEL_REG, &reg_val_flash_sel);
+    if (err) {
+        dev_err(dev,
+            "%s: error during trigger output flash select register read (%d)\n",
+            __func__, err);
+        goto exit;
+    }
+
+    err = topaz2m_read_reg(s_data, TOPAZ2M_TRIG_OUT_AIMER_MODE_REG, &reg_val_aimer_mode);
+    if (err) {
+        dev_err(dev,
+            "%s: error during trigger output aimer mode register read (%d)\n",
+            __func__, err);
+        goto exit;
+    }
+
+    if (TOPAZ2M_TRIG_OUT_END <= val) {
+        val = 0;
+    }
+
+    flash_sel_on_trig = topaz2m_trigger_out_table[val].flash_sel_on_trig;
+    aimer_mode = topaz2m_trigger_out_table[val].aimer_mode;
+    trig_out_sel = topaz2m_trigger_out_table[val].trig_out_sel;
+
+    reg_val_flash_sel = (reg_val_flash_sel & TOPAZ2M_TRIG_OUT_FLASH_SEL_MASK) |
+                        (flash_sel_on_trig << TOPAZ2M_TRIG_OUT_FLASH_SEL_OFFSET);
+    reg_val_aimer_mode = (reg_val_aimer_mode & TOPAZ2M_TRIG_OUT_AIMER_MODE_MASK) |
+                         (aimer_mode << TOPAZ2M_TRIG_OUT_AIMER_MODE_OFFSET);
+
+    err = topaz2m_write_reg(s_data, TOPAZ2M_TRIG_OUT_FLASH_SEL_REG, reg_val_flash_sel);
+    if (err) {
+        dev_err(dev,
+            "%s: Could not write trigger output flash selection value (%d). Write error.",
+            __func__, reg_val_flash_sel);
+        goto exit;
+    }
+
+    dev_dbg(dev, "%s: Updated Trigger Output Flash Selection Register 0x%02x to: 0x%04x\n", __func__,
+        TOPAZ2M_TRIG_OUT_FLASH_SEL_REG, reg_val_flash_sel);
+
+    err = topaz2m_write_reg(s_data, TOPAZ2M_TRIG_OUT_AIMER_MODE_REG, reg_val_aimer_mode);
+    if (err) {
+        dev_err(dev,
+            "%s: Could not write trigger output aimer mode value (%d). Write error.",
+            __func__, reg_val_aimer_mode);
+        goto exit;
+    }
+
+    dev_dbg(dev, "%s: Updated Trigger Output Aimer Mode Register 0x%02x to: 0x%04x\n", __func__,
+        TOPAZ2M_TRIG_OUT_FLASH_SEL_REG, reg_val_aimer_mode);
+
+    err = topaz2m_write_reg(s_data, TOPAZ2M_TRIG_OUT_SEL_REG, trig_out_sel);
+    if (err) {
+        dev_err(dev,
+            "%s: Could not write trigger output selection value (%d). Write error.",
+            __func__, trig_out_sel);
+        goto exit;
+    }
+
+    dev_dbg(dev, "%s: Updated Trigger Output Selection Register 0x%02x to: 0x%04x\n", __func__,
+        TOPAZ2M_TRIG_OUT_SEL_REG, trig_out_sel);
+
+exit:
+    return err;
+}
+
+static int topaz2m_set_flash_delay(struct tegracam_device *tc_dev, s64 val, topaz2m_flash_delay_type delay_type)
+{
+    struct camera_common_data *s_data = NULL;
+    struct device *dev = NULL;
+    u16 reg_val = 0;
+    int err = 0;
+
+    if (!tc_dev) {
+        pr_err("%s:%d tc_dev is null", __func__, __LINE__);
+        err = -EINVAL;
+        goto exit;
+    }
+
+    s_data = tc_dev->s_data;
+    dev = tc_dev->dev;
+
+    err = topaz2m_read_reg(s_data, TOPAZ2M_FLASH_DELAY_REG, &reg_val);
+    if (err) {
+        dev_err(dev,
+            "%s: error during flash delay register read (%d)\n",
+            __func__, err);
+        goto exit;
+    }
+
+    if (TOPAZ2M_FLASH_DELAY_ON == delay_type) {
+        reg_val = (reg_val & TOPAZ2M_FLASH_DELAY_ON_MASK) | val;
+    } else if (TOPAZ2M_FLASH_DELAY_OFF == delay_type) {
+        reg_val = (reg_val & TOPAZ2M_FLASH_DELAY_OFF_MASK) | (val << TOPAZ2M_FLASH_DELAY_OFF_OFFSET);
+    } else {
+        dev_err(dev, "%s: Received invalid delay type: %d", __func__, delay_type);
+        err = -EINVAL;
+        goto exit;
+    }
+
+    err = topaz2m_write_reg(s_data, TOPAZ2M_FLASH_DELAY_REG, reg_val);
+
+    if (err) {
+        dev_err(dev,
+            "%s: Could not write flash delay value (%d). Write error.",
+            __func__, reg_val);
+        goto exit;
+    }
+
+    dev_dbg(dev, "%s: Updated Flash Delay Register 0x%02x to: 0x%04x\n", __func__,
+        TOPAZ2M_FLASH_DELAY_REG, reg_val);
+
+exit:
+    return err;
+}
+
+static int topaz2m_set_flash_delay_on(struct tegracam_device *tc_dev, s64 val)
+{
+    struct device *dev = NULL;
+    int err = 0;
+
+    if (!tc_dev) {
+        pr_err("%s:%d tc_dev is null", __func__, __LINE__);
+        err = -EINVAL;
+        goto exit;
+    }
+
+    dev = tc_dev->dev;
+
+    err = topaz2m_set_flash_delay(tc_dev, val, TOPAZ2M_FLASH_DELAY_ON);
+
+    if (err) {
+        dev_err(dev, "%s: Could not set flash delay on value.", __func__);
+        goto exit;
+    }
+
+exit:
+    return err;
+}
+
+static int topaz2m_set_flash_delay_off(struct tegracam_device *tc_dev, s64 val)
+{
+    struct device *dev = NULL;
+    int err = 0;
+
+    if (!tc_dev) {
+        pr_err("%s:%d tc_dev is null", __func__, __LINE__);
+        err = -EINVAL;
+        goto exit;
+    }
+
+    dev = tc_dev->dev;
+
+    err = topaz2m_set_flash_delay(tc_dev, val, TOPAZ2M_FLASH_DELAY_OFF);
+
+    if (err) {
+        dev_err(dev, "%s: Could not set flash delay off value.", __func__);
+        goto exit;
+    }
+
+exit:
+    return err;
+}
+
+static int topaz2m_set_image_offset(struct tegracam_device *tc_dev, s64 val)
+{
+    struct camera_common_data *s_data = NULL;
+    struct device *dev = NULL;
+    u16 reg_val = 0;
+    int err = 0;
+
+    if (!tc_dev) {
+        pr_err("%s:%d tc_dev is null", __func__, __LINE__);
+        err = -EINVAL;
+        goto exit;
+    }
+
+    s_data = tc_dev->s_data;
+    dev = tc_dev->dev;
+
+    reg_val = val & TOPAZ2M_IMAGE_OFFSET_MASK;
+
+    err = topaz2m_write_reg(s_data, TOPAZ2M_IMAGE_OFFSET_REG, reg_val);
+
+    if (err) {
+        dev_err(dev,
+            "%s: Could not write image offset value (%d). Write error.",
+            __func__, reg_val);
+        goto exit;
+    }
+
+    dev_dbg(dev, "%s: Updated Image Offset Register 0x%02x to: 0x%04x\n", __func__,
+        TOPAZ2M_IMAGE_OFFSET_REG, reg_val);
+
+exit:
+    return err;
+}
+
+static int topaz2m_get_module_resolution(struct tegracam_device *tc_dev, s64 *val)
+{
+    struct device *dev = NULL;
+    struct topaz2m *priv = NULL;
+    unsigned int reg_val = 0;
+    int err = 0;
+
+    if (!tc_dev | !val) {
+        pr_err("%s:%d Either tc_dev  or val is null", __func__, __LINE__);
+        err = -EINVAL;
+        goto exit;
+    }
+
+    dev = tc_dev->dev;
+    priv = (struct topaz2m *)tegracam_get_privdata(tc_dev);
+
+    err = topaz2m_eeprom_read_word(priv, TOPAZ2M_MODULE_RESOLUTION_ADDR, &reg_val);
+
+    if (err) {
+        dev_err(dev,
+            "%s: Could not read EEPROM module resolution value. Read error.",
+            __func__);
+        goto exit;
+    }
+
+    switch (reg_val) {
+    case TOPAZ2M_MODULE_RESOLUTION_1_MP: {
+        *val  = TOPAZ2M_MODULE_RESOLUTION_1_MP_VAL;
+        break;
+    }
+    case TOPAZ2M_MODULE_RESOLUTION_2_MP: {
+        *val  = TOPAZ2M_MODULE_RESOLUTION_2_MP_VAL;
+        break;
+    }
+    case TOPAZ2M_MODULE_RESOLUTION_3_MP: {
+        *val  = TOPAZ2M_MODULE_RESOLUTION_3_MP_VAL;
+        break;
+    }
+    case TOPAZ2M_MODULE_RESOLUTION_5_MP: {
+        *val  = TOPAZ2M_MODULE_RESOLUTION_5_MP_VAL;
+        break;
+    }
+    default: {
+        *val = TOPAZ2M_MODULE_RESOLUTION_DEFAULT_VAL;
+        dev_warn(dev, "Unknown module resolution: %x\n", reg_val);
+        break;
+    }
+    }
+
+exit:
+    return err;
+}
+
+static int topaz2m_get_module_option(struct tegracam_device *tc_dev, s64 *val)
+{
+    struct device *dev = NULL;
+    struct topaz2m *priv = NULL;
+    unsigned int reg_val = 0;
+    int err = 0;
+
+    if (!tc_dev | !val) {
+        pr_err("%s:%d Either tc_dev or val is null", __func__, __LINE__);
+        err = -EINVAL;
+        goto exit;
+    }
+
+    dev = tc_dev->dev;
+    priv = (struct topaz2m *)tegracam_get_privdata(tc_dev);
+
+    err = topaz2m_eeprom_read_word(priv, TOPAZ2M_MODULE_OPTION_ADDR, &reg_val);
+
+    if (err) {
+        dev_err(dev,
+            "%s: Could not read EEPROM module option value. Read error.",
+            __func__);
+        goto exit;
+    }
+
+    switch (reg_val) {
+    case TOPAZ2M_MODULE_OPT_NO_LENS: {
+        *val  = TOPAZ2M_MODULE_OPT_NO_LENS_VAL;
+        break;
+    }
+    case TOPAZ2M_MODULE_OPT_FIXED: {
+        *val  = TOPAZ2M_MODULE_OPT_FIXED_VAL;
+        break;
+    }
+    case TOPAZ2M_MODULE_OPT_AUTO: {
+        *val  = TOPAZ2M_MODULE_OPT_AUTO_VAL;
+        break;
+    }
+    default: {
+        *val = TOPAZ2M_MODULE_OPT_DEFAULT_VAL;
+        dev_warn(dev, "Unknown module option: %x\n", reg_val);
+        break;
+    }
+    }
+
+exit:
+    return err;
+}
+
+static int topaz2m_get_is_color(struct tegracam_device *tc_dev, s64 *val)
+{
+    struct device *dev = NULL;
+    struct topaz2m *priv = NULL;
+    unsigned int reg_val = 0;
+    int err = 0;
+
+    if (!tc_dev | !val) {
+        pr_err("%s:%d Either tc_dev or val is null", __func__, __LINE__);
+        err = -EINVAL;
+        goto exit;
+    }
+
+    dev = tc_dev->dev;
+    priv = (struct topaz2m *)tegracam_get_privdata(tc_dev);
+
+    err = topaz2m_eeprom_read_word(priv, TOPAZ2M_IS_COLOR_ADDR, &reg_val);
+
+    if (err) {
+        dev_err(dev,
+            "%s: Could not read EEPROM color value. Read error.",
+            __func__);
+        goto exit;
+    }
+
+    if (TOPAZ2M_IS_COLOR_TRUE == reg_val) {
+        *val  = TOPAZ2M_IS_COLOR_TRUE_VAL;
+    } else {
+        *val  = TOPAZ2M_IS_COLOR_FALSE_VAL;
+    }
+
+exit:
+    return err;
+}
+
+static int topaz2m_get_is_multifocus(struct tegracam_device *tc_dev, s64 *val)
+{
+    struct device *dev = NULL;
+    struct topaz2m *priv = NULL;
+    unsigned int reg_val = 0;
+    int err = 0;
+
+    if (!tc_dev | !val) {
+            pr_err("%s:%d Either tc_dev or val is null", __func__, __LINE__);
+        err = -EINVAL;
+        goto exit;
+    }
+
+    dev = tc_dev->dev;
+    priv = (struct topaz2m *)tegracam_get_privdata(tc_dev);
+
+    err = topaz2m_eeprom_read_word(priv, TOPAZ2M_IS_MULTIFOCUS_ADDR, &reg_val);
+
+    if (err) {
+        dev_err(dev,
+            "%s: Could not read EEPROM multifocus MSB value. Read error.",
+            __func__);
+        goto exit;
+    }
+
+    if (TOPAZ2M_IS_MULTIFOCUS_TRUE == reg_val) {
+        *val = TOPAZ2M_IS_MULTIFOCUS_TRUE_VAL;
+    } else {
+        *val = TOPAZ2M_IS_MULTIFOCUS_FALSE_VAL;
+    }
+
+exit:
+    return err;
+}
+
+static int topaz2m_get_focus_dac(struct tegracam_device *tc_dev, s64 *val)
+{
+    struct device *dev = NULL;
+    struct topaz2m *priv = NULL;
+    u8 msb_val = 0;
+    u8 msb_pol = 0;
+    u8 msb_abs_val = 0;
+    u8 lsb_val = 0;
+    int err = 0;
+
+    if (!tc_dev) {
+        pr_err("%s:%d tc_dev is null", __func__, __LINE__);
+        err = -EINVAL;
+        goto exit;
+    }
+
+    dev = tc_dev->dev;
+    priv = (struct topaz2m *)tegracam_get_privdata(tc_dev);
+
+    if (!priv->tlens_enabled) {
+        dev_info(dev,
+            "%s: Cannot get focus dac, tlens support is disabled",
+            __func__);
+        /* This method should exit successfully since it is called during driver
+         * setup regardless of whether the sensor supports it or not
+         */
+        err = 0;
+        goto exit;
+    }
+
+    err = topaz2m_tlens_read_reg(priv, TOPAZ2M_TLENS_DAC_MSB_ADDR, &msb_val);
+
+    if (err) {
+        dev_err(dev,
+            "%s: Could not read tlens dac msb value. Read error.",
+            __func__);
+        goto exit;
+    }
+
+    err = topaz2m_tlens_read_reg(priv, TOPAZ2M_TLENS_DAC_LSB_ADDR, &lsb_val);
+
+    if (err) {
+        dev_err(dev,
+            "%s: Could not read tlens dac lsb value. Read error.",
+            __func__);
+        goto exit;
+    }
+
+    /* The Tlens focus value is stored as a polarity and an abolute value.
+     * To decode the value, first the polarity is obtained. Then the msb and the
+     * lsb are joined to obtain the absolute value. In case the polarity is
+     * negative, the absolute value is finally negated to obtain the final value.
+     */
+    msb_pol = msb_val & TOPAZ2M_TLENS_DAC_POS_MASK;
+    msb_abs_val = msb_val & ~TOPAZ2M_TLENS_DAC_POS_MASK;
+    *val = (msb_abs_val << TOPAZ2M_TLENS_DAC_MSB_SHIFT) | lsb_val;
+    if (TOPAZ2M_TLENS_DAC_NEG_MASK == msb_pol) {
+        *val = -*val;
+    }
+
+exit:
+    return err;
+}
+
+static int topaz2m_set_focus_dac(struct tegracam_device *tc_dev, s64 val)
+{
+    struct device *dev = NULL;
+    struct topaz2m *priv = NULL;
+    s32 trunc_val = val;
+    u16 abs_val = 0;
+    u8 msb_val = 0;
+    u8 lsb_val = 0;
+    int err = 0;
+
+    if (!tc_dev) {
+        pr_err("%s:%d tc_dev is null", __func__, __LINE__);
+        err = -EINVAL;
+        goto exit;
+    }
+
+    dev = tc_dev->dev;
+    priv = (struct topaz2m *)tegracam_get_privdata(tc_dev);
+
+    if (!priv->tlens_enabled) {
+        dev_info(dev,
+            "%s: Cannot set focus dac, tlens support is disabled",
+            __func__);
+        /* This method should exit successfully since it is called during driver
+         * setup regardless of whether the sensor supports it or not
+         */
+        err = 0;
+        goto exit;
+    }
+
+    if (!priv->is_streaming) {
+        dev_err(dev,
+            "%s: Cannot set focus dac, sensor is not currently streaming",
+            __func__);
+        /* This method should exit successfully since it should allow to be
+         * called regardless of whether the sensor is streaming or not
+         */
+        err = 0;
+        goto exit;
+    }
+
+    /* The Tlens focus value is written as a polarity and absolute value.
+     * To obtain the Tlens focus register values from a focus value, first the
+     * polarity bit is set, and the absolute value of the value is obtained.
+     * Then the most significant bits of the absolute value are obtained by
+     * applying a mask and shifting the bits to their corresponding register
+     * position. The least significant bits of the absolue value are obtained by
+     * simply applying a mask.
+     */
+    if (trunc_val >= 0) {
+        msb_val = TOPAZ2M_TLENS_DAC_POS_MASK;
+        abs_val = trunc_val;
+    } else {
+        msb_val = TOPAZ2M_TLENS_DAC_NEG_MASK;
+        abs_val = -trunc_val;
+    }
+
+    msb_val |= (abs_val & TOPAZ2M_TLENS_DAC_MSB_MASK) >> TOPAZ2M_TLENS_DAC_MSB_SHIFT;
+    lsb_val = (abs_val & TOPAZ2M_TLENS_DAC_LSB_MASK);
+
+    err = topaz2m_tlens_write_reg(priv, TOPAZ2M_TLENS_DAC_MSB_ADDR, msb_val);
+
+    if (err) {
+        dev_err(dev,
+            "%s: Could not write tlens dac msb value (%d). Write error.",
+            __func__, msb_val);
+        goto exit;
+    }
+
+    dev_dbg(dev, "%s: Updated Tlens DAC MSB Register 0x%02x to: 0x%02x\n", __func__,
+        TOPAZ2M_TLENS_DAC_MSB_ADDR, msb_val);
+
+    err = topaz2m_tlens_write_reg(priv, TOPAZ2M_TLENS_DAC_LSB_ADDR, lsb_val);
+
+    if (err) {
+        dev_err(dev,
+            "%s: Could not write tlens dac lsb value (%d). Write error.",
+            __func__, lsb_val);
+        goto exit;
+    }
+
+    dev_dbg(dev, "%s: Updated Tlens DAC LSB Register 0x%02x to: 0x%02x\n", __func__,
+        TOPAZ2M_TLENS_DAC_LSB_ADDR, lsb_val);
+
+    priv->focus_dac_value = trunc_val;
+
+exit:
+    return err;
+}
+
+static int topaz2m_read_temperature(struct topaz2m *priv, u8 msb_addr, u8 lsb_addr, s64 *temperature) {
+    struct device *dev = NULL;
+    u8 range_val = 0;
+    bool is_extended = false;
+    u8 msb_val = 0;
+    u8 lsb_val = 0;
+    s64 integer_part = 0;
+    s64 decimal_part = 0;
+    int err = 0;
+
+    if (!priv) {
+        pr_err("%s:%d priv is null", __func__, __LINE__);
+        err = -EINVAL;
+        goto exit;
+    }
+
+    dev = priv->tc_dev->dev;
+
+    err = topaz2m_temp_read_reg(priv, TOPAZ2M_TEMP_RANGE_READ_ADDR, &range_val);
+
+    if (err) {
+        dev_err(dev,
+            "%s: Could not read temperature range value. Read error.",
+            __func__);
+        goto exit;
+    }
+
+    is_extended = TOPAZ2M_TEMP_RANGE_MASK == (range_val & TOPAZ2M_TEMP_RANGE_MASK);
+
+    err = topaz2m_temp_read_reg(priv, msb_addr, &msb_val);
+
+    if (err) {
+        dev_err(dev,
+            "%s: Could not read temperature msb value. Read error.",
+            __func__);
+        goto exit;
+    }
+
+    err = topaz2m_temp_read_reg(priv, lsb_addr, &lsb_val);
+
+    if (err) {
+        dev_err(dev,
+            "%s: Could not read temperature lsb value. Read error.",
+            __func__);
+        goto exit;
+    }
+
+    /* The temperature is separated into an integer part and a decimal part.
+     * The integer and decimal parts are read from separate 8-bit registers.
+     * The decimal part consists of 4 decimal places. In order to return the
+     * temperature as an integer value, the complete temperature is multiplied
+     * by a conversion factor of 10000. The 8-bit decimal part is then right
+     * shifted by 8, which has the effect of dividing the register value to
+     * obtain the proper decimal value.
+     */
+    integer_part = msb_val*TOPAZ2M_TEMP_CONVERSION_FACTOR;
+    decimal_part = (lsb_val*TOPAZ2M_TEMP_CONVERSION_FACTOR) >> TOPAZ2M_TEMP_LSB_SHIFT;
+
+    *temperature = integer_part + decimal_part;
+
+    /* In case the temperature is in extended form, an offset must be subtracted
+     * from the integer part of the temperature in order to obtain the proper
+     * temperature.
+     */
+    if (is_extended) {
+        *temperature -= TOPAZ2M_TEMP_EXTENDED_OFFSET*TOPAZ2M_TEMP_CONVERSION_FACTOR;
+    }
+
+    /* The temperature value is clamped between a minimum and maximum value.
+     * This is done for two reasons:
+     * - Since the control is a volatile, read-only control, v4l2 does not clamp
+     *   the value automatically.
+     * - Since the range of the temperature registers is larger than the desired
+     *   control range, it is possible for the temperature to reach values
+     *   outside the control range.
+     */
+    if (TOPAZ2M_TEMP_MIN_VALUE > *temperature) {
+        *temperature = TOPAZ2M_TEMP_MIN_VALUE;
+    }
+
+    if (TOPAZ2M_TEMP_MAX_VALUE < *temperature) {
+        *temperature = TOPAZ2M_TEMP_MAX_VALUE;
+    }
+
+exit:
+    return err;
+}
+
+static int topaz2m_get_module_temperature(struct tegracam_device *tc_dev, s64 *val)
+{
+    struct device *dev = NULL;
+    struct topaz2m *priv = NULL;
+    int err = 0;
+
+    if (!tc_dev) {
+        pr_err("%s:%d tc_dev is null", __func__, __LINE__);
+        err = -EINVAL;
+        goto exit;
+    }
+
+    dev = tc_dev->dev;
+    priv = (struct topaz2m *)tegracam_get_privdata(tc_dev);
+
+    if (!priv->temp_enabled) {
+        dev_info(dev,
+            "%s: Cannot get module temperature, temperature sensor support is disabled",
+            __func__);
+        /* This method should exit successfully since it is called during driver
+         * setup regardless of whether the sensor supports it or not
+         */
+        err = 0;
+        goto exit;
+    }
+
+    err = topaz2m_read_temperature(priv, TOPAZ2M_TEMP_LOCAL_TEMP_MSB_ADDR, TOPAZ2M_TEMP_LOCAL_TEMP_LSB_ADDR, val);
+
+    if (err) {
+        dev_err(dev,
+            "%s: Could not read module temperature. Read error.",
+            __func__);
+        goto exit;
+    }
+
+exit:
+    return err;
+}
+
+static int topaz2m_get_sensor_temperature(struct tegracam_device *tc_dev, s64 *val)
+{
+    struct device *dev = NULL;
+    struct topaz2m *priv = NULL;
+    int err = 0;
+
+    if (!tc_dev) {
+        pr_err("%s:%d tc_dev is null", __func__, __LINE__);
+        err = -EINVAL;
+        goto exit;
+    }
+
+    dev = tc_dev->dev;
+    priv = (struct topaz2m *)tegracam_get_privdata(tc_dev);
+
+    if (!priv->temp_enabled) {
+        dev_info(dev,
+            "%s: Cannot get sensor temperature, temperature sensor support is disabled",
+            __func__);
+        /* This method should exit successfully since it is called during driver
+         * setup regardless of whether the sensor supports it or not
+         */
+        err = 0;
+        goto exit;
+    }
+
+    err = topaz2m_read_temperature(priv, TOPAZ2M_TEMP_REMOTE_TEMP_MSB_ADDR, TOPAZ2M_TEMP_REMOTE_TEMP_LSB_ADDR, val);
+
+    if (err) {
+        dev_err(dev,
+            "%s: Could not read sensor temperature. Read error.",
+            __func__);
+        goto exit;
+    }
+
+exit:
+    return err;
+}
+
+static int topaz2m_set_temperature_range(struct tegracam_device *tc_dev, s64 val)
+{
+    struct device *dev = NULL;
+    struct topaz2m *priv = NULL;
+    u8 reg_val = 0;
+    int err = 0;
+
+    if (!tc_dev) {
+        pr_err("%s:%d tc_dev is null", __func__, __LINE__);
+        err = -EINVAL;
+        goto exit;
+    }
+
+    dev = tc_dev->dev;
+    priv = (struct topaz2m *)tegracam_get_privdata(tc_dev);
+
+    if (!priv->temp_enabled) {
+        dev_info(dev,
+            "%s: Cannot set temperature range, temperature sensor support is disabled",
+            __func__);
+        /* This method should exit successfully since it is called during driver
+         * setup regardless of whether the sensor supports it or not
+         */
+        err = 0;
+        goto exit;
+    }
+
+    err = topaz2m_temp_read_reg(priv, TOPAZ2M_TEMP_RANGE_READ_ADDR, &reg_val);
+
+    if (err) {
+        dev_err(dev,
+            "%s: Could not read temperature range register. Read error.",
+            __func__);
+        goto exit;
+    }
+
+    if (TOPAZ2M_TEMP_RANGE_EXT_VAL == val) {
+        reg_val |= TOPAZ2M_TEMP_RANGE_MASK;
+    } else {
+        reg_val &= ~TOPAZ2M_TEMP_RANGE_MASK;
+    }
+
+    err = topaz2m_temp_write_reg(priv, TOPAZ2M_TEMP_RANGE_WRITE_ADDR, reg_val);
+
+    if (err) {
+        dev_err(dev,
+            "%s: Could not write temperature range register. Write error.",
+            __func__);
+        goto exit;
+    }
+
+exit:
+    return err;
+}
+
+static struct tegracam_ctrl_ops topaz2m_ctrl_ops = {
+    .numctrls = ARRAY_SIZE(ctrl_cid_list),
+    .ctrl_cid_list = ctrl_cid_list,
+    .set_gain = topaz2m_set_gain,
+    .set_exposure = topaz2m_set_exposure,
+    .set_frame_rate = topaz2m_set_frame_rate,
+    .set_group_hold = topaz2m_set_group_hold,
+    .set_analog_gain = topaz2m_set_analog_gain,
+    .set_digital_gain = topaz2m_set_digital_gain,
+    .set_test_pattern = topaz2m_set_test_pattern,
+    .set_flip = topaz2m_set_flip,
+    .set_color_gain_b = topaz2m_set_color_gain_b,
+    .set_color_gain_g = topaz2m_set_color_gain_g,
+    .set_color_gain_r = topaz2m_set_color_gain_r,
+    .set_color_offset_b = topaz2m_set_color_offset_b,
+    .set_color_offset_g = topaz2m_set_color_offset_g,
+    .set_color_offset_r = topaz2m_set_color_offset_r,
+    .set_trigger_output = topaz2m_set_trigger_output,
+    .set_flash_delay_on = topaz2m_set_flash_delay_on,
+    .set_flash_delay_off = topaz2m_set_flash_delay_off,
+    .set_image_offset = topaz2m_set_image_offset,
+    .get_module_resolution = topaz2m_get_module_resolution,
+    .get_module_option = topaz2m_get_module_option,
+    .get_is_color = topaz2m_get_is_color,
+    .get_is_multifocus = topaz2m_get_is_multifocus,
+    .set_focus_dac = topaz2m_set_focus_dac,
+    .get_focus_dac = topaz2m_get_focus_dac,
+    .get_module_temperature = topaz2m_get_module_temperature,
+    .get_sensor_temperature = topaz2m_get_sensor_temperature,
+    .set_temperature_range = topaz2m_set_temperature_range,
+};
+
+static int topaz2m_power_on(struct camera_common_data *s_data)
+{
+    int err = 0;
+    struct camera_common_power_rail *pw = NULL;
+    struct camera_common_pdata *pdata = NULL;
+    struct device *dev = NULL;
+
+    if (!s_data) {
+        pr_err("%s:%d s_data is null", __func__, __LINE__);
+        return -EINVAL;
+    }
+
+    pw = s_data->power;
+    pdata = s_data->pdata;
+    dev = s_data->dev;
+
+    dev_dbg(dev, "%s: power on\n", __func__);
+    if (pdata && pdata->power_on) {
+        err = pdata->power_on(pw);
+        if (err)
+            dev_err(dev, "%s failed.\n", __func__);
+        else
+            pw->state = SWITCH_ON;
+        return err;
+    }
+
+    if (pw->pwdn_gpio) {
+        if (gpio_cansleep(pw->pwdn_gpio))
+            gpio_set_value_cansleep(pw->pwdn_gpio, 1);
+        else
+            gpio_set_value(pw->pwdn_gpio, 1);
+    }
+
+    usleep_range(23000, 23100);
+
+    pw->state = SWITCH_ON;
+
+    return 0;
+}
+
+static int topaz2m_power_off(struct camera_common_data *s_data)
+{
+    int err = 0;
+    struct camera_common_power_rail *pw = NULL;
+    struct camera_common_pdata *pdata = NULL;
+    struct device *dev = NULL;
+
+    if (!s_data) {
+        pr_err("%s:%d s_data is null", __func__, __LINE__);
+        return -EINVAL;
+    }
+
+    pw = s_data->power;
+    pdata = s_data->pdata;
+    dev = s_data->dev;
+
+    dev_dbg(dev, "%s: power off\n", __func__);
+
+    if (pdata && pdata->power_off) {
+        err = pdata->power_off(pw);
+        if (err) {
+            dev_err(dev, "%s failed.\n", __func__);
+            return err;
+        }
+    } else {
+        if (pw->pwdn_gpio) {
+            if (gpio_cansleep(pw->pwdn_gpio))
+                gpio_set_value_cansleep(pw->pwdn_gpio, 0);
+            else
+                gpio_set_value(pw->pwdn_gpio, 0);
+        }
+
+        usleep_range(2000, 2010);
+    }
+
+    pw->state = SWITCH_OFF;
+
+    return 0;
+}
+
+static int topaz2m_power_put(struct tegracam_device *tc_dev)
+{
+    struct camera_common_data *s_data = NULL;
+    struct camera_common_power_rail *pw = NULL;
+
+    if (!tc_dev) {
+        pr_err("%s:%d tc_dev is null", __func__, __LINE__);
+        return -EINVAL;
+    }
+
+    s_data = tc_dev->s_data;
+    pw = s_data->power;
+
+    if (unlikely(!pw))
+        return -EFAULT;
+
+    if (likely(pw->pwdn_gpio))
+        gpio_free(pw->pwdn_gpio);
+
+    return 0;
+}
+
+static int topaz2m_power_get(struct tegracam_device *tc_dev)
+{
+    struct device *dev = NULL;
+    struct camera_common_data *s_data = NULL;
+    struct camera_common_power_rail *pw = NULL;
+    struct camera_common_pdata *pdata = NULL;
+    int err = 0;
+
+    if (!tc_dev) {
+        pr_err("%s:%d tc_dev is null", __func__, __LINE__);
+        err = -EINVAL;
+        goto exit;
+    }
+
+    dev = tc_dev->dev;
+    s_data = tc_dev->s_data;
+    pw = s_data->power;
+    pdata = s_data->pdata;
+
+    if (!pdata) {
+        dev_err(dev, "pdata missing\n");
+        err = -EFAULT;
+        goto exit;
+    }
+
+    /* ENABLE GPIO */
+    pw->pwdn_gpio = pdata->pwdn_gpio;
+    err = gpio_request(pw->pwdn_gpio, "cam_pwdn_gpio");
+    if (err < 0)
+        dev_err(dev, "%s: unable to request reset_gpio (%d)\n",
+            __func__, err);
+
+    pw->state = SWITCH_OFF;
+
+exit:
+    return err;
+}
+
+static struct camera_common_pdata *topaz2m_parse_dt(struct tegracam_device
+                            *tc_dev)
+{
+    struct device *dev = NULL;
+    struct device_node *np = NULL;
+    struct camera_common_pdata *board_priv_pdata = NULL;
+    const struct of_device_id *match = NULL;
+    struct camera_common_pdata *ret = NULL;
+    int gpio = 0;
+
+    if (!tc_dev) {
+        pr_err("%s:%d tc_dev is null", __func__, __LINE__);
+        ret = ERR_PTR(-EINVAL);
+        goto exit;
+    }
+
+    dev = tc_dev->dev;
+    np = dev->of_node;
+
+    if (!np) {
+        ret = ERR_PTR(-EINVAL);
+        goto exit;
+    }
+
+    match = of_match_device(topaz2m_of_match, dev);
+    if (!match) {
+        dev_err(dev, "Failed to find matching dt id\n");
+        ret = ERR_PTR(-EINVAL);
+        goto exit;
+    }
+
+    board_priv_pdata = devm_kzalloc(dev,
+                    sizeof(*board_priv_pdata), GFP_KERNEL);
+    if (!board_priv_pdata) {
+        ret = ERR_PTR(-EINVAL);
+        goto exit;
+    }
+
+    gpio = of_get_named_gpio(np, "pwdn-gpios", 0);
+    if (gpio < 0) {
+        if (gpio == -EPROBE_DEFER)
+            ret = ERR_PTR(-EPROBE_DEFER);
+        dev_err(dev, "pwdn-gpios not found\n");
+        goto err_exit;
+    }
+    board_priv_pdata->pwdn_gpio = (unsigned int)gpio;
+
+    return board_priv_pdata;
+
+err_exit:
+    devm_kfree(dev, board_priv_pdata);
+
+exit:
+    return ret;
+}
+
+static int topaz2m_set_mode(struct tegracam_device *tc_dev)
+{
+    struct topaz2m *priv = NULL;
+    struct device *dev = NULL;
+    struct camera_common_data *s_data = NULL;
+    int err = 0;
+    topaz2m_reg *trigger_mode_table = NULL;
+
+    if (!tc_dev) {
+        pr_err("%s:%d tc_dev is null", __func__, __LINE__);
+        err = -EINVAL;
+        goto exit;
+    }
+
+    priv = (struct topaz2m *)tegracam_get_privdata(tc_dev);
+    dev = tc_dev->dev;
+    s_data = tc_dev->s_data;
+
+    if (!priv->mode_table) {
+        dev_err(dev, "mode_table missing\n");
+        err = -EFAULT;
+        goto exit;
+    }
+
+    if (priv->is_1M5) {
+        switch (s_data->mode) {
+        case TOPAZ2M_MODE_1920X1080_10B_EXT_FRAME_TRIG:
+        case TOPAZ2M_MODE_1920X1080_8B_EXT_FRAME_TRIG:
+        case TOPAZ2M_MODE_1920X1080_10B_EXT_ITC_TRIG:
+        case TOPAZ2M_MODE_1920X1080_8B_EXT_ITC_TRIG:
+        case TOPAZ2M_MODE_1920X1080_10B_INT_SELF_TRIG:
+        case TOPAZ2M_MODE_1920X1080_8B_INT_SELF_TRIG: {
+            dev_info(dev, "1920x1080 resolution modes are not supported for 1.5M sensor\n");
+            err = -EINVAL;
+            goto exit;
+        }
+        default: {
+            break;
+        }
+        }
+    }
+
+    err = topaz2m_write_table(priv, priv->mode_table[TOPAZ2M_MODE_COMMON]);
+    if (err)
+        goto exit;
+
+    switch (s_data->mode) {
+    case TOPAZ2M_MODE_1920X1080_10B_EXT_FRAME_TRIG:
+    case TOPAZ2M_MODE_1920X800_10B_EXT_FRAME_TRIG:
+    case TOPAZ2M_MODE_1920X1080_8B_EXT_FRAME_TRIG:
+    case TOPAZ2M_MODE_1920X800_8B_EXT_FRAME_TRIG: {
+        trigger_mode_table = mode_external_frame_trigger;
+        break;
+    }
+    case TOPAZ2M_MODE_1920X1080_10B_EXT_ITC_TRIG:
+    case TOPAZ2M_MODE_1920X800_10B_EXT_ITC_TRIG:
+    case TOPAZ2M_MODE_1920X1080_8B_EXT_ITC_TRIG:
+    case TOPAZ2M_MODE_1920X800_8B_EXT_ITC_TRIG: {
+        trigger_mode_table = mode_external_itc_trigger;
+        break;
+    }
+    case TOPAZ2M_MODE_1920X1080_10B_INT_SELF_TRIG:
+    case TOPAZ2M_MODE_1920X800_10B_INT_SELF_TRIG:
+    case TOPAZ2M_MODE_1920X1080_8B_INT_SELF_TRIG:
+    case TOPAZ2M_MODE_1920X800_8B_INT_SELF_TRIG:
+    default: {
+        trigger_mode_table = mode_internal_self_trigger;
+        break;
+    }
+    }
+
+    err = topaz2m_write_table(priv, trigger_mode_table);
+
+    if (err) {
+        dev_err(tc_dev->dev, "error in writing trigger mode register\n");
+        goto exit;
+    }
+
+    err = topaz2m_write_pixel_timing_table(priv, timing_pixel);
+    if (err) {
+        dev_err(tc_dev->dev, "error in writing pixel timing table\n");
+        goto exit;
+    }
+
+    err = topaz2m_write_table(priv, priv->mode_table[s_data->mode]);
+    if (err)
+        goto exit;
+
+exit:
+    return err;
+}
+
+static int topaz2m_start_streaming(struct tegracam_device *tc_dev)
+{
+    struct topaz2m *priv = NULL;
+    struct device *dev = NULL;
+    int err = 0;
+
+    if (!tc_dev) {
+        pr_err("%s:%d tc_dev is null", __func__, __LINE__);
+        err = -EINVAL;
+        goto exit;
+    }
+
+    priv = (struct topaz2m *)tegracam_get_privdata(tc_dev);
+    dev = tc_dev->dev;
+
+    if (!priv->mode_table) {
+        dev_err(dev, "mode_table missing\n");
+        err = -EFAULT;
+        goto exit;
+    }
+
+    err = topaz2m_write_table(priv, priv->mode_table[TOPAZ2M_MODE_START_STREAM]);
+    if (err) {
+        dev_err(dev, "could not start streaming\n");
+        err = -EINVAL;
+        goto exit;
+    }
+
+    priv->is_streaming = true;
+    if (priv->tlens_enabled) {
+        err = topaz2m_set_focus_dac(tc_dev, priv->focus_dac_value);
+        if (err) {
+            dev_err(dev, "could not update focus dac value\n");
+            err = -EINVAL;
+            goto exit;
+        }
+    }
+
+exit:
+    return err;
+}
+
+static int topaz2m_stop_streaming(struct tegracam_device *tc_dev)
+{
+    struct topaz2m *priv = NULL;
+    struct device *dev = NULL;
+    s64 last_focus_value = 0;
+    int err = 0;
+
+    if (!tc_dev) {
+        pr_err("%s:%d tc_dev is null", __func__, __LINE__);
+        err = -EINVAL;
+        goto exit;
+    }
+
+    priv = (struct topaz2m *)tegracam_get_privdata(tc_dev);
+    dev = tc_dev->dev;
+
+    if (priv->tlens_enabled) {
+        last_focus_value = priv->focus_dac_value;
+        err = topaz2m_set_focus_dac(tc_dev, 0);
+        if (err) {
+            dev_err(dev, "could not set focus dac to 0\n");
+            err =  -EINVAL;
+            goto exit;
+        }
+        priv->focus_dac_value = last_focus_value;
+    }
+
+    if (!priv->mode_table) {
+        dev_err(dev, "mode_table missing\n");
+        err = -EFAULT;
+        goto exit;
+    }
+
+    err = topaz2m_write_table(priv, priv->mode_table[TOPAZ2M_MODE_STOP_STREAM]);
+
+    if (err) {
+        dev_err(dev, "could not stop stream\n");
+        err = -EINVAL;
+        goto exit;
+    }
+
+    priv->is_streaming = false;
+
+exit:
+    return err;
+}
+
+static struct camera_common_sensor_ops topaz2m_common_ops = {
+    .numfrmfmts = ARRAY_SIZE(topaz2m_frmfmt),
+    .frmfmt_table = topaz2m_frmfmt,
+    .power_on = topaz2m_power_on,
+    .power_off = topaz2m_power_off,
+    .write_reg = NULL,
+    .read_reg = NULL,
+    .parse_dt = topaz2m_parse_dt,
+    .power_get = topaz2m_power_get,
+    .power_put = topaz2m_power_put,
+    .set_mode = topaz2m_set_mode,
+    .start_streaming = topaz2m_start_streaming,
+    .stop_streaming = topaz2m_stop_streaming,
+};
+
+static int topaz2m_eeprom_setup(struct topaz2m *priv) {
+    const char *eeprom_name = TOPAZ2M_EEPROM_NAME;
+    struct device *dev = NULL;
+    int err = 0;
+
+    if (!priv) {
+        pr_err("%s:%d priv is null", __func__, __LINE__);
+        err =  -EINVAL;
+        goto exit;
+    }
+
+    dev = priv->tc_dev->dev;
+
+    priv->eeprom.adapter = i2c_get_adapter(priv->i2c_client->adapter->nr);
+
+    memset(&priv->eeprom.board_info, 0, sizeof(priv->eeprom.board_info));
+
+    strncpy(priv->eeprom.board_info.type, eeprom_name, sizeof(priv->eeprom.board_info.type));
+
+    priv->eeprom.board_info.addr = TOPAZ2M_EEPROM_I2C_ADDRESS;
+
+    priv->eeprom.client = i2c_new_client_device(priv->eeprom.adapter, &priv->eeprom.board_info);
+
+    priv->eeprom.regmap = devm_regmap_init_i2c(
+            priv->eeprom.client, &eeprom_regmap_config);
+
+    if (IS_ERR(priv->eeprom.regmap)) {
+        err = PTR_ERR(priv->eeprom.regmap);
+        dev_err(dev, "eeprom regmap initialization failed\n");
+        goto exit;
+    }
+
+exit:
+    return err;
+}
+
+static int topaz2m_tlens_setup(struct topaz2m *priv) {
+    const char *tlens_name = TOPAZ2M_TLENS_NAME;
+    struct device *dev = NULL;
+    s64 focus_dac_val = 0;
+    int err = 0;
+    unsigned int i = 0;
+
+    if (!priv) {
+        pr_err("%s:%d priv is null", __func__, __LINE__);
+        err =  -EINVAL;
+        goto exit;
+    }
+
+    dev = priv->tc_dev->dev;
+
+    /* Tlens device initialization */
+    priv->tlens.adapter = i2c_get_adapter(priv->i2c_client->adapter->nr);
+    memset(&priv->tlens.board_info, 0, sizeof(priv->tlens.board_info));
+    strncpy(priv->tlens.board_info.type, tlens_name, sizeof(priv->tlens.board_info.type));
+    priv->tlens.board_info.addr = TOPAZ2M_TLENS_I2C_ADDRESS;
+    priv->tlens.client = i2c_new_client_device(priv->tlens.adapter, &priv->tlens.board_info);
+    priv->tlens.regmap = devm_regmap_init_i2c(
+            priv->tlens.client, &tlens_regmap_config);
+
+    if (IS_ERR(priv->tlens.regmap)) {
+        err = PTR_ERR(priv->tlens.regmap);
+        dev_err(dev, "tlens regmap initialization failed\n");
+        goto exit;
+    }
+
+    /* Tlens driver activation */
+    err = topaz2m_tlens_write_reg(priv, TOPAZ2M_TLENS_MODE_ADDR, TOPAZ2M_TLENS_ENABLE_VAL);
+    if (err) {
+        dev_err(dev, "tlens startup sequence mode register write failed");
+        goto exit;
+    }
+
+    /* Tlens warmup sequence */
+    for (i = 0; i < sizeof(topaz2m_tlens_warmup_table)/sizeof(s64); ++i) {
+        focus_dac_val = topaz2m_tlens_warmup_table[i];
+        err = topaz2m_set_focus_dac(priv->tc_dev, focus_dac_val);
+        if (err) {
+            dev_err(dev, "tlens startup sequence failed while writing value: %lld", focus_dac_val);
+            goto exit;
+        }
+
+        msleep_range(TOPAZ2M_TLENS_WARMUP_DELAY_MS);
+    }
+
+exit:
+    return err;
+}
+
+static int topaz2m_temp_setup(struct topaz2m *priv) {
+    const char *temp_name = TOPAZ2M_TEMP_NAME;
+    struct device *dev = NULL;
+    u8 reg_val = 0;
+    int err = 0;
+
+    if (!priv) {
+        pr_err("%s:%d priv is null", __func__, __LINE__);
+        err =  -EINVAL;
+        goto exit;
+    }
+
+    dev = priv->tc_dev->dev;
+
+    /* Temperature sensor device initialization */
+    priv->temp.adapter = i2c_get_adapter(priv->i2c_client->adapter->nr);
+    memset(&priv->temp.board_info, 0, sizeof(priv->temp.board_info));
+    strncpy(priv->temp.board_info.type, temp_name, sizeof(priv->temp.board_info.type));
+    priv->temp.board_info.addr = TOPAZ2M_TEMP_I2C_ADDRESS;
+    priv->temp.client = i2c_new_client_device(priv->temp.adapter, &priv->temp.board_info);
+    priv->temp.regmap = devm_regmap_init_i2c(
+            priv->temp.client, &temp_regmap_config);
+
+    if (IS_ERR(priv->temp.regmap)) {
+        err = PTR_ERR(priv->temp.regmap);
+        dev_err(dev, "temperature sensor regmap initialization failed\n");
+        goto exit;
+    }
+
+    /* Test sensor */
+    err = topaz2m_temp_read_reg(priv, TOPAZ2M_TEMP_RANGE_READ_ADDR, &reg_val);
+
+    if (err) {
+        dev_err(dev,
+            "%s: Temperature sensor test failed.",
+            __func__);
+        goto exit;
+    }
+
+exit:
+    return err;
+}
+
+static int topaz2m_board_setup(struct topaz2m *priv)
+{
+    struct camera_common_data *s_data = NULL;
+    struct device *dev = NULL;
+    struct tegracam_device *tc_dev = NULL;
+    u16 reg_val = 0;
+    s64 is_color = 0;
+    s64 resolution = 0;
+    s64 module_option = 0;
+    int err = 0;
+
+    if (!priv) {
+        pr_err("%s:%d priv is null", __func__, __LINE__);
+        err = -EINVAL;
+        goto exit;
+    }
+
+    s_data = priv->s_data;
+    dev = s_data->dev;
+    tc_dev = priv->tc_dev;
+
+    err = topaz2m_power_on(s_data);
+    if (err) {
+        dev_err(dev, "error during power on sensor (%d)\n", err);
+        goto exit;
+    }
+
+    /* Read sensor model */
+    err = topaz2m_read_reg(s_data, TOPAZ2M_MODEL_ID_ADDR, &reg_val);
+    if (err) {
+        dev_err(dev, "%s: error during i2c read probe (%d)\n", __func__,
+            err);
+        goto power_off;
+    }
+
+    /* Chip family Check */
+    reg_val &= TOPAZ2M_MODEL_ID_MASK;
+
+    if (reg_val == TOPAZ2M_SENSOR_ID) {
+        dev_info(dev, "Topaz sensor found\n");
+    } else {
+        dev_err(dev, "No Topaz sensor found\n");
+        err = -ENODEV;
+        goto power_off;
+    }
+
+    dev_info(dev, "Topaz driver version: %s\n", TOPAZ2M_VERSION);
+
+    /* EEPROM setup */
+    err = topaz2m_eeprom_setup(priv);
+    if (err) {
+        dev_err(dev, "EEPROM setup failed\n");
+        goto power_off;
+    }
+
+    /* Color setup */
+    err = topaz2m_get_is_color(tc_dev, &is_color);
+    if (err) {
+        dev_err(dev, "Could not determine if sensor is color or monochrome\n");
+        goto power_off;
+    }
+
+    if (TOPAZ2M_IS_COLOR_TRUE_VAL == is_color) {
+        priv->mode_table = &mode_table_color[0];
+        priv->color_enabled = true;
+        dev_info(dev, "Topaz sensor type: color\n");
+    } else {
+        priv->mode_table = &mode_table_bw[0];
+        priv->color_enabled = false;
+        dev_info(dev, "Topaz sensor type: monochrome\n");
+    }
+
+    /* Resolution setup */
+    err = topaz2m_get_module_resolution(tc_dev, &resolution);
+    if (err) {
+        dev_err(dev, "Could not determine sensor resolution\n");
+        goto power_off;
+    }
+
+    /* Setting default value */
+    priv->is_1M5 = false;
+
+    switch(resolution) {
+    case TOPAZ2M_MODULE_RESOLUTION_1_MP_VAL: {
+        priv->is_1M5 = true;
+        dev_info(dev, "Topaz sensor resolution: 1.5M\n");
+        break;
+    }
+    case TOPAZ2M_MODULE_RESOLUTION_2_MP_VAL: {
+        dev_info(dev, "Topaz sensor resolution: 2M\n");
+        break;
+    }
+    case TOPAZ2M_MODULE_RESOLUTION_3_MP: {
+        dev_info(dev, "Topaz sensor resolution: 3.2M\n");
+        break;
+    }
+    case TOPAZ2M_MODULE_RESOLUTION_5_MP: {
+        dev_info(dev, "Topaz sensor resolution: 5M\n");
+        break;
+    }
+    default: {
+        dev_info(dev, "Topaz sensor does not have a supported resolution. Enabling 2M support\n");
+        break;
+    }
+    }
+
+    /* TLENS setup */
+    err = topaz2m_get_module_option(tc_dev, &module_option);
+    if (err) {
+        dev_err(dev, "Could not determine sensor module option\n");
+        goto power_off;
+    }
+
+    /* Setting default value */
+    priv->tlens_enabled = false;
+
+    switch (module_option) {
+    case TOPAZ2M_MODULE_OPT_NO_LENS_VAL: {
+        dev_info(dev, "Topaz sensor module option: No-Lens\n");
+        break;
+    }
+    case TOPAZ2M_MODULE_OPT_FIXED_VAL: {
+        dev_info(dev, "Topaz sensor module option: Fixed-Focus\n");
+        break;
+    }
+    case TOPAZ2M_MODULE_OPT_AUTO_VAL: {
+        priv->tlens_enabled = true;
+        priv->is_streaming = true;
+        err = topaz2m_tlens_setup(priv);
+        if (err) {
+            dev_err(dev, "Tlens setup failed\n");
+            goto power_off;
+        }
+        dev_info(dev, "Topaz sensor module option: Multifocus\n");
+        break;
+    }
+    default: {
+        dev_info(dev, "Topaz sensor does not have a supported module option\n");
+        break;
+    }
+    }
+    priv->is_streaming = false;
+
+    /* Setting default value */
+    priv->temp_enabled = true;
+
+    /* Temperature sensor setup */
+    err = topaz2m_temp_setup(priv);
+    if (err) {
+        dev_info(dev, "Topaz temperature sensor support disabled\n");
+        priv->temp_enabled = false;
+        err = 0;
+    } else {
+        dev_info(dev, "Topaz temperature sensor support enabled.\n");
+    }
+
+    goto exit;
+
+power_off:
+    topaz2m_power_off(s_data);
+exit:
+    return err;
+}
+
+static int topaz2m_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+    struct i2c_client *client = NULL;
+
+    /* This null check excludes the unused fh parameter */
+    if (!sd) {
+        pr_err("%s:%d sd is null", __func__, __LINE__);
+        return -EINVAL;
+    }
+
+    client = v4l2_get_subdevdata(sd);
+
+    dev_dbg(&client->dev, "%s:\n", __func__);
+
+    return 0;
+}
+
+static const struct v4l2_subdev_internal_ops topaz2m_subdev_internal_ops = {
+    .open = topaz2m_open,
+};
+
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+static const struct v4l2_subdev_core_ops topaz2m_subdev_core_ops = {
+    .g_register = topaz2m_eeprom_g_register,
+    .s_register = topaz2m_eeprom_s_register,
+};
+#endif /* CONFIG_VIDEO_ADV_DEBUG */
+
+static int topaz2m_probe(struct i2c_client *client,
+             const struct i2c_device_id *id)
+{
+    const char *sensor_name = TOPAZ2M_SENSOR_NAME;
+    struct device *dev = NULL;
+    struct tegracam_device *tc_dev = NULL;
+    struct topaz2m *priv = NULL;
+    int err = 0;
+
+    /* This null check excludes the unused id parameter */
+    if (!client) {
+        pr_err("%s:%d client is null", __func__, __LINE__);
+        err = -EINVAL;
+        goto exit;
+    }
+
+    dev = &client->dev;
+
+    dev_dbg(dev, "probing v4l2 sensor at addr 0x%0x\n", client->addr);
+
+    if (!IS_ENABLED(CONFIG_OF) || !client->dev.of_node) {
+        err = -EINVAL;
+        goto exit;
+    }
+
+    priv = devm_kzalloc(dev, sizeof(struct topaz2m), GFP_KERNEL);
+    if (!priv) {
+        err = -ENOMEM;
+        goto exit;
+    }
+
+    tc_dev = devm_kzalloc(dev, sizeof(struct tegracam_device), GFP_KERNEL);
+    if (!tc_dev) {
+        err = -ENOMEM;
+        goto exit;
+    }
+
+    priv->i2c_client = client;
+    tc_dev->client = client;
+    tc_dev->dev = dev;
+    strncpy(tc_dev->name, sensor_name, sizeof(tc_dev->name));
+    tc_dev->dev_regmap_config = &sensor_regmap_config;
+    tc_dev->sensor_ops = &topaz2m_common_ops;
+    tc_dev->v4l2sd_internal_ops = &topaz2m_subdev_internal_ops;
+    tc_dev->tcctrl_ops = &topaz2m_ctrl_ops;
+
+    err = tegracam_device_register(tc_dev);
+    if (err) {
+        dev_err(dev, "tegra camera driver registration failed\n");
+        goto exit;
+    }
+
+    priv->tc_dev = tc_dev;
+    priv->s_data = tc_dev->s_data;
+    priv->subdev = &tc_dev->s_data->subdev;
+    tegracam_set_privdata(tc_dev, (void *)priv);
+
+    err = topaz2m_board_setup(priv);
+    if (err) {
+        dev_err(dev, "board setup failed\n");
+        goto unregister;
+    }
+
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+    tegracam_v4l2subdev_set_debug_register_controls(&topaz2m_subdev_core_ops);
+#endif /* CONFIG_VIDEO_ADV_DEBUG */
+
+    err = tegracam_v4l2subdev_register(tc_dev, true);
+    if (err) {
+        dev_err(dev, "tegra camera subdev registration failed\n");
+        goto unregister;
+    }
+
+    dev_info(dev, "detected topaz2m sensor\n");
+
+    goto exit;
+
+unregister:
+    tegracam_device_unregister(priv->tc_dev);
+exit:
+    return err;
+}
+
+static int topaz2m_remove(struct i2c_client *client)
+{
+    struct camera_common_data *s_data = NULL;
+    struct topaz2m *priv = NULL;
+
+    if (!client) {
+        pr_err("%s:%d client is null", __func__, __LINE__);
+        return -EINVAL;
+    }
+
+    s_data = to_camera_common_data(&client->dev);
+    priv = (struct topaz2m *)s_data->priv;
+
+    tegracam_v4l2subdev_unregister(priv->tc_dev);
+    tegracam_device_unregister(priv->tc_dev);
+
+    return 0;
+}
+
+static const struct i2c_device_id topaz2m_id[] = {
+    {TOPAZ2M_SENSOR_NAME, 0},
+    {}
+};
+
+MODULE_DEVICE_TABLE(i2c, topaz2m_id);
+
+static struct i2c_driver topaz2m_i2c_driver = {
+    .driver = {
+           .name = TOPAZ2M_SENSOR_NAME,
+           .owner = THIS_MODULE,
+           .of_match_table = of_match_ptr(topaz2m_of_match),
+           },
+    .probe = topaz2m_probe,
+    .remove = topaz2m_remove,
+    .id_table = topaz2m_id,
+};
+
+module_i2c_driver(topaz2m_i2c_driver);
+
+MODULE_DESCRIPTION("V4L2 driver for TOPAZ2M sensor");
+MODULE_AUTHOR("Eduardo Salazar <eduardo.salazar@ridgerun.com>");
+MODULE_LICENSE("GPL v2");
+MODULE_VERSION(TOPAZ2M_VERSION);
diff --git a/kernel/nvidia/drivers/media/i2c/topaz2m_mode_tbls.h b/kernel/nvidia/drivers/media/i2c/topaz2m_mode_tbls.h
new file mode 100644
index 000000000..7f8aba01f
--- /dev/null
+++ b/kernel/nvidia/drivers/media/i2c/topaz2m_mode_tbls.h
@@ -0,0 +1,1270 @@
+/*
+ * topaz2m_mode_tbls.h - topaz2m sensor driver
+ *
+ * Copyright (c) 2024, RidgeRun, LLC. All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef TOPAZ2M_I2C_TABLES
+#define TOPAZ2M_I2C_TABLES
+
+#define TOPAZ2M_TABLE_WAIT_MS               0
+#define TOPAZ2M_TABLE_END                   0x60
+#define TOPAZ2M_TABLE_END_VAL               0x0000
+#define TOPAZ2M_RAM_OFFSET_REGISTER         0x4F
+#define TOPAZ2M_MAX_RETRIES                 3
+#define TOPAZ2M_WAIT_MS                     3
+
+#define TOPAZ2M_ANA_GAIN_ADDR               0x0D
+#define TOPAZ2M_DIG_GAIN_ADDR               0x0E
+
+/* The digital gain register is a 12-bit value, with a maximum value of 4095 and
+ * a minimum value of 1. This range is determined from the sensor documentation
+ * provided by Teledyne as follows:
+ * - The sensor digital gain ranges from 0.004 to 16 and it is obtained by
+ *   dividing the register value by 256.
+ * - Since the minimum value of 0.004 is obtained from 1/256, then the minimum
+ *   register value is 1.
+ * - Since the maximum value of 16 can be obtained from 4095/256 and since the
+ *   maximum 12-bit value is 4095, then the maximum register value is 4095.
+ */
+#define TOPAZ2M_DIG_GAIN_MAX                4095
+#define TOPAZ2M_DIG_GAIN_MIN                1
+
+#define TOPAZ2M_LINE_LENGTH_REG             0x06
+#define TOPAZ2M_FRAME_RATE_PERIOD_VALUE     0x07
+#define TOPAZ2M_EXPOSURE_COARSE_TIME_REG    0x0B
+#define TOPAZ2M_EXPOSURE_FINE_TIME_REG      0x0C
+#define TOPAZ2M_ROI1_REG                    0x13
+
+/* The color gain registers are 10-bit values, with a maximum value of 1023 and
+ * a minimum value of 1. This range is determined from the sensor documentation
+ * provided by Teledyne as follows:
+ * - The sensor color gains range from 0.004 to 4 and these are obtained by
+ *   dividing the register values by 256.
+ * - Since the minimum value of 0.004 is obtained from 1/256, then the minimum
+ *   register value is 64.
+ * - Since the maximum value of 4 can be obtained from 1023/256 and since the
+ *   maximum 10-bit value is 1023, then the maximum register value is 1023.
+ */
+#define TOPAZ2M_COLOR_GAIN_MAX              1023
+#define TOPAZ2M_COLOR_GAIN_MIN              1
+
+/* There are four color gain registers for the 4 colors in the bayer pattern */
+#define TOPAZ2M_COLOR_GAIN_B_REG            0x1e
+#define TOPAZ2M_COLOR_GAIN_GB_REG           0x1f
+#define TOPAZ2M_COLOR_GAIN_R_REG            0x20
+#define TOPAZ2M_COLOR_GAIN_GR_REG           0x21
+
+/* There are four 8-bit color offsets for the 4 colors in the bayer pattern.
+ * These values are placed in 2 16-bit registers, where each register has 2
+ * values. The red and blue offsets are placed in the LSB of their registers.
+ * The green offsets are placed in the MSB of their registers. To account for
+ * this, a green offset shift value is defined.
+ */
+#define TOPAZ2M_COLOR_OFFSET_B_REG          0x1c
+#define TOPAZ2M_COLOR_OFFSET_GB_REG         0x1c
+#define TOPAZ2M_COLOR_OFFSET_R_REG          0x1d
+#define TOPAZ2M_COLOR_OFFSET_GR_REG         0x1d
+#define TOPAZ2M_GREEN_OFFSET_SHIFT          8
+
+#define TOPAZ2M_TEST_PATTERN_MODE_REG       0x04
+#define TOPAZ2M_TEST_PATTERN_MODE_MASK      0xFFFC
+#define TOPAZ2M_TEST_PATTERN_CONFIG_1_REG   0x25
+#define TOPAZ2M_TEST_PATTERN_CONFIG_2_REG   0x26
+
+#define TOPAZ2M_TRIG_OUT_FLASH_SEL_REG      0x05
+#define TOPAZ2M_TRIG_OUT_FLASH_SEL_MASK     0xFDFF
+#define TOPAZ2M_TRIG_OUT_FLASH_SEL_OFFSET   9
+#define TOPAZ2M_TRIG_OUT_AIMER_MODE_REG     0x04
+#define TOPAZ2M_TRIG_OUT_AIMER_MODE_MASK    0xCFFF
+#define TOPAZ2M_TRIG_OUT_AIMER_MODE_OFFSET  12
+#define TOPAZ2M_TRIG_OUT_SEL_REG            0x9a
+
+#define TOPAZ2M_FLASH_DELAY_REG             0x09
+#define TOPAZ2M_FLASH_DELAY_ON_MASK         0xFF00
+#define TOPAZ2M_FLASH_DELAY_OFF_MASK        0x00FF
+#define TOPAZ2M_FLASH_DELAY_OFF_OFFSET      8
+
+#define TOPAZ2M_IMAGE_OFFSET_REG            0x22
+#define TOPAZ2M_IMAGE_OFFSET_MASK           0x03FF
+
+/* EEPROM access */
+#define TOPAZ2M_EEPROM_I2C_ADDRESS          0x50
+#define TOPAZ2M_MODULE_RESOLUTION_ADDR      0x0688
+#define TOPAZ2M_MODULE_OPTION_ADDR          0x0690
+#define TOPAZ2M_IS_COLOR_ADDR               0x068C
+#define TOPAZ2M_IS_MULTIFOCUS_ADDR          0x0690
+
+/* TLENS access */
+#define TOPAZ2M_TLENS_I2C_ADDRESS           0x0C
+#define TOPAZ2M_TLENS_MODE_ADDR             0x00
+#define TOPAZ2M_TLENS_DAC_MSB_ADDR          0x02
+#define TOPAZ2M_TLENS_DAC_LSB_ADDR          0x03
+#define TOPAZ2M_TLENS_DAC_POS_MASK          0x80
+#define TOPAZ2M_TLENS_DAC_NEG_MASK          0x00
+#define TOPAZ2M_TLENS_DAC_MSB_MASK          0x300
+#define TOPAZ2M_TLENS_DAC_MSB_SHIFT         8
+#define TOPAZ2M_TLENS_DAC_LSB_MASK          0xFF
+
+/* Temperature sensor access */
+#define TOPAZ2M_TEMP_I2C_ADDRESS            0x4E
+#define TOPAZ2M_TEMP_LOCAL_TEMP_MSB_ADDR    0x00
+#define TOPAZ2M_TEMP_LOCAL_TEMP_LSB_ADDR    0x15
+#define TOPAZ2M_TEMP_REMOTE_TEMP_MSB_ADDR   0x01
+#define TOPAZ2M_TEMP_REMOTE_TEMP_LSB_ADDR   0x10
+#define TOPAZ2M_TEMP_CONVERSION_FACTOR      10000
+#define TOPAZ2M_TEMP_LSB_SHIFT              8
+#define TOPAZ2M_TEMP_EXTENDED_OFFSET        64
+#define TOPAZ2M_TEMP_RANGE_WRITE_ADDR       0x09
+#define TOPAZ2M_TEMP_RANGE_READ_ADDR        0x03
+#define TOPAZ2M_TEMP_RANGE_MASK             0x04
+#define TOPAZ2M_TEMP_RANGE_EXT_VAL          1
+#define TOPAZ2M_TEMP_MIN_VALUE              -400000
+#define TOPAZ2M_TEMP_MAX_VALUE              1250000
+
+typedef struct reg_8_16 topaz2m_reg;
+
+/* Register configuration for the timing pixel register */
+static topaz2m_reg timing_pixel[] = {
+    {0x50, 0x0552},
+    {0x50, 0xd550},
+    {0x50, 0xf551},
+    {0x50, 0xf551},
+    {0x50, 0xf551},
+    {0x50, 0xf551},
+    {0x50, 0xf551},
+    {0x50, 0xf551},
+    {0x50, 0xf551},
+    {0x50, 0xf551},
+    {0x50, 0xf551},
+    {0x50, 0xf551},
+    {0x50, 0xf551},
+    {0x50, 0x8551},
+    {0x50, 0xf550},
+    {0x50, 0x4550},
+    {0x50, 0xf552},
+    {0x50, 0xe552},
+    {0x50, 0x153a},
+    {0x50, 0xf532},
+    {0x50, 0x5532},
+    {0x50, 0xa552},
+    {0x50, 0xf152},
+    {0x50, 0xf152},
+    {0x50, 0x7152},
+    {0x50, 0x9156},
+    {0x50, 0xf114},
+    {0x50, 0xf114},
+    {0x50, 0xf114},
+    {0x50, 0xf114},
+    {0x50, 0xf114},
+    {0x50, 0xf114},
+    {0x50, 0xf114},
+    {0x50, 0x2114},
+    {0x50, 0xf110},
+    {0x50, 0xf110},
+    {0x50, 0xf110},
+    {0x50, 0xb110},
+    {0x50, 0xf510},
+    {0x50, 0x8510},
+    {0x50, 0x9550},
+    {0x50, 0x4552},
+    {0x50, 0x9512},
+    {0x50, 0xf532},
+    {0x50, 0xd532},
+    {0x50, 0xf53a},
+    {0x50, 0xf53a},
+    {0x50, 0xf53a},
+    {0x50, 0xf53a},
+    {0x50, 0xf53a},
+    {0x50, 0xf53a},
+    {0x50, 0xf53a},
+    {0x50, 0xf53a},
+    {0x50, 0xf53a},
+    {0x50, 0x553a},
+    {0x50, 0x142a},
+    {0x50, 0x202a},
+    {0x50, 0xf02e},
+    {0x50, 0xa02e},
+    {0x50, 0x802c},
+    {0x50, 0x300c},
+    {0x50, 0x404c},
+    {0x50, 0xf34c},
+    {0x50, 0xf34c},
+    {0x50, 0x734c},
+    {0x50, 0x014c},
+    {0x50, 0x304c},
+    {0x50, 0x9044},
+    {0x50, 0xf045},
+    {0x50, 0xf045},
+    {0x50, 0x5045},
+    {0x50, 0x6044},
+    {0x50, 0xe04c},
+    {0x50, 0xf14c},
+    {0x50, 0xf14c},
+    {0x50, 0x714c},
+    {0x50, 0x100c},
+    {0x50, 0x380c},
+    {0x50, 0x582c},
+    {0x50, 0x202c},
+    {0x50, 0x002c},
+    {0x50, 0x8028},
+    {0x50, 0xb02a},
+    {0x50, 0x742a},
+    {0x50, 0x0000},
+    {0x50, 0x0000},
+    {0x50, 0x0000},
+    {0x50, 0x0000},
+    {0x50, 0x0000},
+    {0x50, 0x0000},
+    {0x50, 0x0000},
+    {0x50, 0x0000},
+    {0x50, 0x0000},
+    {0x50, 0x0000},
+    {0x50, 0x0000},
+    {0x50, 0x0000},
+    {0x50, 0x0000},
+    {0x50, 0x0000},
+    {0x50, 0x0000},
+    {0x50, 0x0000},
+    {0x50, 0x0000},
+    {0x50, 0x0000},
+    {0x50, 0x0000},
+    {0x50, 0x0000},
+    {0x50, 0x0000},
+    {0x50, 0x0000},
+    {0x50, 0x0000},
+    {0x50, 0x0000},
+    {0x50, 0x0000},
+    {0x50, 0x0000},
+    {0x50, 0x0000},
+    {0x50, 0x0000},
+    {0x50, 0x0000},
+    {0x50, 0x0000},
+    {0x50, 0x0000},
+    {0x50, 0x0000},
+    {0x50, 0x0000},
+    {0x50, 0x0000},
+    {0x50, 0x0000},
+    {0x50, 0x0000},
+    {0x50, 0x0000},
+    {0x50, 0x0000},
+    {0x50, 0x0000},
+    {0x50, 0x0000},
+    {0x50, 0x0000},
+    {0x50, 0x0000},
+    {0x50, 0x0000},
+    {0x50, 0x0000},
+    {0x50, 0x0012},
+    {0x50, 0x000d},
+    {0x50, 0x0018},
+    {0x50, 0x0019},
+    {0x50, 0x0004},
+    {0x50, 0x0000},
+    {0x50, 0x002a},
+    {0x50, 0x0012},
+    {0x50, 0x0037},
+    {0x50, 0x0050},
+    {0x50, 0x0000},
+    {0x50, 0x0000},
+    {0x50, 0x0000},
+    {0x50, 0x0000},
+    {0x50, 0x0000},
+    {0x50, 0x0000},
+    {0x50, 0x0000},
+    {0x50, 0x0000},
+    {0x50, 0x0000},
+    {0x50, 0x0000},
+    {0x50, 0x0000},
+    {0x50, 0x0000},
+    {0x50, 0x0000},
+    {0x50, 0x0000},
+    {TOPAZ2M_TABLE_END, TOPAZ2M_TABLE_END_VAL}
+};
+
+static topaz2m_reg mode_table_common[] = {
+    {TOPAZ2M_TABLE_WAIT_MS, 10},
+    {0x01, 0x0000},
+    {0x02, 0x0001},
+    {0x03, 0x002f},
+    {TOPAZ2M_TABLE_END, TOPAZ2M_TABLE_END_VAL}
+};
+
+static topaz2m_reg mode_internal_self_trigger[] = {
+    {0x03, 0x002f},
+    {TOPAZ2M_TABLE_END, TOPAZ2M_TABLE_END_VAL}
+};
+
+static topaz2m_reg mode_external_frame_trigger[] = {
+    {0x03, 0x082f},
+    {TOPAZ2M_TABLE_END, TOPAZ2M_TABLE_END_VAL}
+};
+
+static topaz2m_reg mode_external_itc_trigger[] = {
+    {0x03, 0x0c2f},
+    {TOPAZ2M_TABLE_END, TOPAZ2M_TABLE_END_VAL}
+};
+
+/* 1920x1080@65fps, 2 lanes, line length = 650, RAW10 */
+static topaz2m_reg mode_1920x1080_10b[] = {
+    {TOPAZ2M_TABLE_WAIT_MS, 10},
+    {0x04, 0xa0d0},
+    {0x05, 0x0015},
+    {0x06, 0x028a},
+    {0x07, 0x049f},
+    {0x08, 0x0000},
+    {0x09, 0x0000},
+    {0x0a, 0x1a1f},
+    {0x0b, 0x0438},
+    {0x0c, 0x0000},
+    {0x0d, 0x0000},
+    {0x0e, 0x0100},
+    {0x0f, 0x0438},
+    {0x10, 0x0780},
+    {0x11, 0x0000},
+    {0x12, 0x0000},
+    {0x13, 0x0000},
+    {0x14, 0x0005},
+    {0x15, 0x0000},
+    {0x16, 0x0000},
+    {0x17, 0x0100},
+    {0x18, 0x0438},
+    {0x19, 0x0000},
+    {0x1a, 0x0000},
+    {0x1b, 0x0000},
+    {0x1c, 0x0000},
+    {0x1d, 0x0000},
+    {0x1e, 0x0100},
+    {0x1f, 0x0100},
+    {0x20, 0x0100},
+    {0x21, 0x0100},
+    {0x22, 0x0000},
+    {0x23, 0x0000},
+    {0x24, 0x0000},
+    {0x25, 0x0009},
+    {0x26, 0x0000},
+    {0x27, 0x1068},
+    {0x28, 0x015e},
+    {0x29, 0x0782},
+    {0x2a, 0x0008},
+    {0x2b, 0x040d},
+    {0x2c, 0x020d},
+    {0x2d, 0x104c},
+    {0x2e, 0x001f},
+    {0x2f, 0x0020},
+    {0x30, 0x0000},
+    {0x80, 0x3f87},
+    {0x81, 0x17ff},
+    {0x82, 0x2924},
+    {0x83, 0x0892},
+    {0x84, 0x09cd},
+    {0x85, 0x11ab},
+    {0x86, 0x004b},
+    {0x87, 0x0000},
+    {0x88, 0x8000},
+    {0x89, 0x00aa},
+    {0x8a, 0x000a},
+    {0x8b, 0x0002},
+    {0x8c, 0x2002},
+    {0x8d, 0x0000},
+    {0x8e, 0x003f},
+    {0x8f, 0x79eb},
+    {0x90, 0x4eaf},
+    {0x91, 0x0001},
+    {0x92, 0x0138},
+    {0x93, 0x0384},
+    {0x94, 0x0000},
+    {0x95, 0x1728},
+    {0x96, 0x001a},
+    {0x97, 0x0008},
+    {0x98, 0x0000},
+    {0x99, 0x040a},
+    {0x9a, 0x0010},
+    {0x9b, 0x0090},
+    {0x9c, 0x0a3e},
+    {0x9d, 0x0a2c},
+    {0x9e, 0x2528},
+    {0x9f, 0x0806},
+    {0xa0, 0x0c0a},
+    {0xa1, 0x0011},
+    {0xa2, 0x001e},
+    {0xa3, 0x0186},
+    {0xa4, 0x03fc},
+    {0xa5, 0x000c},
+    {0xa6, 0x0002},
+    {0xa7, 0x0000},
+    {0xa8, 0x0000},
+    {0xa9, 0x0000},
+    {0xaa, 0x0000},
+    {0xab, 0x0000},
+    {0xac, 0x0000},
+    {0xad, 0x0000},
+    {0xae, 0x0000},
+    {0xaf, 0x0000},
+    {0xb0, 0x0000},
+    {0xb1, 0x0000},
+    {0xb2, 0x0439},
+    {0xb3, 0x0000},
+    {0xb4, 0x000c},
+    {0xb5, 0x0000},
+    {0xb6, 0x8ce0},
+    {0xb7, 0x002b},
+    {TOPAZ2M_TABLE_END, TOPAZ2M_TABLE_END_VAL}
+};
+
+/* 1920x1080@100fps, 2 lanes, line length = 425, RAW8 */
+static topaz2m_reg mode_1920x1080_8b[] = {
+    {TOPAZ2M_TABLE_WAIT_MS, 10},
+    {0x04, 0xa0d0},
+    {0x05, 0x001a},
+    {0x06, 0x01a9},
+    {0x07, 0x0498},
+    {0x08, 0x0000},
+    {0x09, 0x0000},
+    {0x0a, 0x1a1f},
+    {0x0b, 0x0438},
+    {0x0c, 0x0000},
+    {0x0d, 0x0000},
+    {0x0e, 0x0100},
+    {0x0f, 0x0438},
+    {0x10, 0x0780},
+    {0x11, 0x0000},
+    {0x12, 0x0000},
+    {0x13, 0x0000},
+    {0x14, 0x0005},
+    {0x15, 0x0000},
+    {0x16, 0x0000},
+    {0x17, 0x0100},
+    {0x18, 0x0438},
+    {0x19, 0x0000},
+    {0x1a, 0x0000},
+    {0x1b, 0x0000},
+    {0x1c, 0x0000},
+    {0x1d, 0x0000},
+    {0x1e, 0x0100},
+    {0x1f, 0x0100},
+    {0x20, 0x0100},
+    {0x21, 0x0100},
+    {0x22, 0x0000},
+    {0x23, 0x0000},
+    {0x24, 0x0000},
+    {0x25, 0x0009},
+    {0x26, 0x0000},
+    {0x27, 0x1068},
+    {0x28, 0x015e},
+    {0x29, 0x0782},
+    {0x2a, 0x0008},
+    {0x2b, 0x040d},
+    {0x2c, 0x020d},
+    {0x2d, 0x104c},
+    {0x2e, 0x001f},
+    {0x2f, 0x0020},
+    {0x30, 0x0000},
+    {0x80, 0x3f87},
+    {0x81, 0x17ff},
+    {0x82, 0x2924},
+    {0x83, 0x0892},
+    {0x84, 0x09cd},
+    {0x85, 0x11ab},
+    {0x86, 0x004b},
+    {0x87, 0x0000},
+    {0x88, 0x8000},
+    {0x89, 0x00aa},
+    {0x8a, 0x000a},
+    {0x8b, 0x0002},
+    {0x8c, 0x2002},
+    {0x8d, 0x0000},
+    {0x8e, 0x003f},
+    {0x8f, 0x79eb},
+    {0x90, 0x4eaf},
+    {0x91, 0x0001},
+    {0x92, 0x0138},
+    {0x93, 0x0384},
+    {0x94, 0x0000},
+    {0x95, 0x1728},
+    {0x96, 0x001a},
+    {0x97, 0x0008},
+    {0x98, 0x0000},
+    {0x99, 0x040a},
+    {0x9a, 0x0010},
+    {0x9b, 0x0090},
+    {0x9c, 0x0a3e},
+    {0x9d, 0x0a2c},
+    {0x9e, 0x2528},
+    {0x9f, 0x0806},
+    {0xa0, 0x0c0a},
+    {0xa1, 0x0011},
+    {0xa2, 0x001e},
+    {0xa3, 0x0186},
+    {0xa4, 0x03fc},
+    {0xa5, 0x000c},
+    {0xa6, 0x0002},
+    {0xa7, 0x0000},
+    {0xa8, 0x0000},
+    {0xa9, 0x0000},
+    {0xaa, 0x0000},
+    {0xab, 0x0000},
+    {0xac, 0x0000},
+    {0xad, 0x0000},
+    {0xae, 0x0000},
+    {0xaf, 0x0000},
+    {0xb0, 0x0000},
+    {0xb1, 0x0000},
+    {0xb2, 0x0439},
+    {0xb3, 0x0000},
+    {0xb4, 0x000c},
+    {0xb5, 0x0000},
+    {0xb6, 0x8ce0},
+    {0xb7, 0x002b},
+    {TOPAZ2M_TABLE_END, TOPAZ2M_TABLE_END_VAL}
+};
+
+/* 1920x800@80fps, 2 lanes, line length = 650, RAW10 */
+static topaz2m_reg mode_1920x800_10b[] = {
+    {TOPAZ2M_TABLE_WAIT_MS, 10},
+    {0x04, 0xa0d0},
+    {0x05, 0x0015},
+    {0x06, 0x028a},
+    {0x07, 0x03c1},
+    {0x08, 0x0000},
+    {0x09, 0x0000},
+    {0x0a, 0x1a1f},
+    {0x0b, 0x0320},
+    {0x0c, 0x0000},
+    {0x0d, 0x0000},
+    {0x0e, 0x0100},
+    {0x0f, 0x0320},
+    {0x10, 0x0780},
+    {0x11, 0x008C},
+    {0x12, 0x0000},
+    {0x13, 0x0000},
+    {0x14, 0x0005},
+    {0x15, 0x0000},
+    {0x16, 0x0000},
+    {0x17, 0x0100},
+    {0x18, 0x0438},
+    {0x19, 0x0000},
+    {0x1a, 0x0000},
+    {0x1b, 0x0000},
+    {0x1c, 0x0000},
+    {0x1d, 0x0000},
+    {0x1e, 0x0100},
+    {0x1f, 0x0100},
+    {0x20, 0x0100},
+    {0x21, 0x0100},
+    {0x22, 0x0000},
+    {0x23, 0x0000},
+    {0x24, 0x0000},
+    {0x25, 0x0009},
+    {0x26, 0x0000},
+    {0x27, 0x1068},
+    {0x28, 0x015e},
+    {0x29, 0x0782},
+    {0x2a, 0x0008},
+    {0x2b, 0x040d},
+    {0x2c, 0x020d},
+    {0x2d, 0x104c},
+    {0x2e, 0x001f},
+    {0x2f, 0x0020},
+    {0x30, 0x0000},
+    {0x80, 0x3f87},
+    {0x81, 0x17ff},
+    {0x82, 0x2924},
+    {0x83, 0x0892},
+    {0x84, 0x09cd},
+    {0x85, 0x11ab},
+    {0x86, 0x004b},
+    {0x87, 0x0000},
+    {0x88, 0x8000},
+    {0x89, 0x00aa},
+    {0x8a, 0x000a},
+    {0x8b, 0x0002},
+    {0x8c, 0x2002},
+    {0x8d, 0x0000},
+    {0x8e, 0x003f},
+    {0x8f, 0x79eb},
+    {0x90, 0x4eaf},
+    {0x91, 0x0001},
+    {0x92, 0x0138},
+    {0x93, 0x0384},
+    {0x94, 0x0000},
+    {0x95, 0x1728},
+    {0x96, 0x001a},
+    {0x97, 0x0008},
+    {0x98, 0x0000},
+    {0x99, 0x040a},
+    {0x9a, 0x0010},
+    {0x9b, 0x0090},
+    {0x9c, 0x0a3e},
+    {0x9d, 0x0a2c},
+    {0x9e, 0x2528},
+    {0x9f, 0x0806},
+    {0xa0, 0x0c0a},
+    {0xa1, 0x0011},
+    {0xa2, 0x001e},
+    {0xa3, 0x0186},
+    {0xa4, 0x03fc},
+    {0xa5, 0x000c},
+    {0xa6, 0x0002},
+    {0xa7, 0x0000},
+    {0xa8, 0x0000},
+    {0xa9, 0x0000},
+    {0xaa, 0x0000},
+    {0xab, 0x0000},
+    {0xac, 0x0000},
+    {0xad, 0x0000},
+    {0xae, 0x0000},
+    {0xaf, 0x0000},
+    {0xb0, 0x0000},
+    {0xb1, 0x0000},
+    {0xb2, 0x0439},
+    {0xb3, 0x0000},
+    {0xb4, 0x000c},
+    {0xb5, 0x0000},
+    {0xb6, 0x8ce0},
+    {0xb7, 0x002b},
+    {TOPAZ2M_TABLE_END, TOPAZ2M_TABLE_END_VAL}
+};
+
+/* 1920x800@130fps, 2 lanes, line length = 425, RAW8 */
+static topaz2m_reg mode_1920x800_8b[] = {
+    {TOPAZ2M_TABLE_WAIT_MS, 10},
+    {0x04, 0xa0d0},
+    {0x05, 0x001a},
+    {0x06, 0x01a9},
+    {0x07, 0x0389},
+    {0x08, 0x0000},
+    {0x09, 0x0000},
+    {0x0a, 0x1a1f},
+    {0x0b, 0x0320},
+    {0x0c, 0x0000},
+    {0x0d, 0x0000},
+    {0x0e, 0x0100},
+    {0x0f, 0x0320},
+    {0x10, 0x0780},
+    {0x11, 0x008C},
+    {0x12, 0x0000},
+    {0x13, 0x0000},
+    {0x14, 0x0005},
+    {0x15, 0x0000},
+    {0x16, 0x0000},
+    {0x17, 0x0100},
+    {0x18, 0x0438},
+    {0x19, 0x0000},
+    {0x1a, 0x0000},
+    {0x1b, 0x0000},
+    {0x1c, 0x0000},
+    {0x1d, 0x0000},
+    {0x1e, 0x0100},
+    {0x1f, 0x0100},
+    {0x20, 0x0100},
+    {0x21, 0x0100},
+    {0x22, 0x0000},
+    {0x23, 0x0000},
+    {0x24, 0x0000},
+    {0x25, 0x0009},
+    {0x26, 0x0000},
+    {0x27, 0x1068},
+    {0x28, 0x015e},
+    {0x29, 0x0782},
+    {0x2a, 0x0008},
+    {0x2b, 0x040d},
+    {0x2c, 0x020d},
+    {0x2d, 0x104c},
+    {0x2e, 0x001f},
+    {0x2f, 0x0020},
+    {0x30, 0x0000},
+    {0x80, 0x3f87},
+    {0x81, 0x17ff},
+    {0x82, 0x2924},
+    {0x83, 0x0892},
+    {0x84, 0x09cd},
+    {0x85, 0x11ab},
+    {0x86, 0x004b},
+    {0x87, 0x0000},
+    {0x88, 0x8000},
+    {0x89, 0x00aa},
+    {0x8a, 0x000a},
+    {0x8b, 0x0002},
+    {0x8c, 0x2002},
+    {0x8d, 0x0000},
+    {0x8e, 0x003f},
+    {0x8f, 0x79eb},
+    {0x90, 0x4eaf},
+    {0x91, 0x0001},
+    {0x92, 0x0138},
+    {0x93, 0x0384},
+    {0x94, 0x0000},
+    {0x95, 0x1728},
+    {0x96, 0x001a},
+    {0x97, 0x0008},
+    {0x98, 0x0000},
+    {0x99, 0x040a},
+    {0x9a, 0x0010},
+    {0x9b, 0x0090},
+    {0x9c, 0x0a3e},
+    {0x9d, 0x0a2c},
+    {0x9e, 0x2528},
+    {0x9f, 0x0806},
+    {0xa0, 0x0c0a},
+    {0xa1, 0x0011},
+    {0xa2, 0x001e},
+    {0xa3, 0x0186},
+    {0xa4, 0x03fc},
+    {0xa5, 0x000c},
+    {0xa6, 0x0002},
+    {0xa7, 0x0000},
+    {0xa8, 0x0000},
+    {0xa9, 0x0000},
+    {0xaa, 0x0000},
+    {0xab, 0x0000},
+    {0xac, 0x0000},
+    {0xad, 0x0000},
+    {0xae, 0x0000},
+    {0xaf, 0x0000},
+    {0xb0, 0x0000},
+    {0xb1, 0x0000},
+    {0xb2, 0x0439},
+    {0xb3, 0x0000},
+    {0xb4, 0x000c},
+    {0xb5, 0x0000},
+    {0xb6, 0x8ce0},
+    {0xb7, 0x002b},
+    {TOPAZ2M_TABLE_END, TOPAZ2M_TABLE_END_VAL}
+};
+
+/* 1920x1080@65fps, 2 lanes, line length = 650, RAW10, color mode */
+static topaz2m_reg mode_1920x1080_10b_color[] = {
+    {TOPAZ2M_TABLE_WAIT_MS, 10},
+    {0x04, 0xa2d0},
+    {0x05, 0x0015},
+    {0x06, 0x028a},
+    {0x07, 0x049f},
+    {0x08, 0x0000},
+    {0x09, 0x0000},
+    {0x0a, 0x1a1f},
+    {0x0b, 0x0438},
+    {0x0c, 0x0000},
+    {0x0d, 0x0000},
+    {0x0e, 0x0100},
+    {0x0f, 0x0438},
+    {0x10, 0x0780},
+    {0x11, 0x0000},
+    {0x12, 0x0000},
+    {0x13, 0x0000},
+    {0x14, 0x0005},
+    {0x15, 0x0000},
+    {0x16, 0x0000},
+    {0x17, 0x0100},
+    {0x18, 0x0438},
+    {0x19, 0x0000},
+    {0x1a, 0x0000},
+    {0x1b, 0x0000},
+    {0x1c, 0x0000},
+    {0x1d, 0x0000},
+    {0x1e, 0x0100},
+    {0x1f, 0x0100},
+    {0x20, 0x0100},
+    {0x21, 0x0100},
+    {0x22, 0x0000},
+    {0x23, 0x0000},
+    {0x24, 0x0000},
+    {0x25, 0x0009},
+    {0x26, 0x0000},
+    {0x27, 0x1068},
+    {0x28, 0x015e},
+    {0x29, 0x0782},
+    {0x2a, 0x0008},
+    {0x2b, 0x040d},
+    {0x2c, 0x020d},
+    {0x2d, 0x104c},
+    {0x2e, 0x001f},
+    {0x2f, 0x0020},
+    {0x30, 0x0000},
+    {0x80, 0x3f87},
+    {0x81, 0x17ff},
+    {0x82, 0x2924},
+    {0x83, 0x0892},
+    {0x84, 0x09cd},
+    {0x85, 0x11ab},
+    {0x86, 0x004b},
+    {0x87, 0x0000},
+    {0x88, 0x8000},
+    {0x89, 0x00aa},
+    {0x8a, 0x000a},
+    {0x8b, 0x0002},
+    {0x8c, 0x2002},
+    {0x8d, 0x0000},
+    {0x8e, 0x003f},
+    {0x8f, 0x79eb},
+    {0x90, 0x4eaf},
+    {0x91, 0x0001},
+    {0x92, 0x0138},
+    {0x93, 0x0384},
+    {0x94, 0x0000},
+    {0x95, 0x1728},
+    {0x96, 0x001a},
+    {0x97, 0x0008},
+    {0x98, 0x0000},
+    {0x99, 0x040a},
+    {0x9a, 0x0010},
+    {0x9b, 0x0090},
+    {0x9c, 0x0a3e},
+    {0x9d, 0x0a2c},
+    {0x9e, 0x2528},
+    {0x9f, 0x0806},
+    {0xa0, 0x0c0a},
+    {0xa1, 0x0011},
+    {0xa2, 0x001e},
+    {0xa3, 0x0186},
+    {0xa4, 0x03fc},
+    {0xa5, 0x000c},
+    {0xa6, 0x0002},
+    {0xa7, 0x0000},
+    {0xa8, 0x0000},
+    {0xa9, 0x0000},
+    {0xaa, 0x0000},
+    {0xab, 0x0000},
+    {0xac, 0x0000},
+    {0xad, 0x0000},
+    {0xae, 0x0000},
+    {0xaf, 0x0000},
+    {0xb0, 0x0000},
+    {0xb1, 0x0000},
+    {0xb2, 0x0439},
+    {0xb3, 0x0000},
+    {0xb4, 0x000c},
+    {0xb5, 0x0000},
+    {0xb6, 0x8ce0},
+    {0xb7, 0x002b},
+    {TOPAZ2M_TABLE_END, TOPAZ2M_TABLE_END_VAL}
+};
+
+/* 1920x1080@100fps, 2 lanes, line length = 425, RAW8, color mode */
+static topaz2m_reg mode_1920x1080_8b_color[] = {
+    {TOPAZ2M_TABLE_WAIT_MS, 10},
+    {0x04, 0xa2d0},
+    {0x05, 0x001a},
+    {0x06, 0x01a9},
+    {0x07, 0x0498},
+    {0x08, 0x0000},
+    {0x09, 0x0000},
+    {0x0a, 0x1a1f},
+    {0x0b, 0x0438},
+    {0x0c, 0x0000},
+    {0x0d, 0x0000},
+    {0x0e, 0x0100},
+    {0x0f, 0x0438},
+    {0x10, 0x0780},
+    {0x11, 0x0000},
+    {0x12, 0x0000},
+    {0x13, 0x0000},
+    {0x14, 0x0005},
+    {0x15, 0x0000},
+    {0x16, 0x0000},
+    {0x17, 0x0100},
+    {0x18, 0x0438},
+    {0x19, 0x0000},
+    {0x1a, 0x0000},
+    {0x1b, 0x0000},
+    {0x1c, 0x0000},
+    {0x1d, 0x0000},
+    {0x1e, 0x0100},
+    {0x1f, 0x0100},
+    {0x20, 0x0100},
+    {0x21, 0x0100},
+    {0x22, 0x0000},
+    {0x23, 0x0000},
+    {0x24, 0x0000},
+    {0x25, 0x0009},
+    {0x26, 0x0000},
+    {0x27, 0x1068},
+    {0x28, 0x015e},
+    {0x29, 0x0782},
+    {0x2a, 0x0008},
+    {0x2b, 0x040d},
+    {0x2c, 0x020d},
+    {0x2d, 0x104c},
+    {0x2e, 0x001f},
+    {0x2f, 0x0020},
+    {0x30, 0x0000},
+    {0x80, 0x3f87},
+    {0x81, 0x17ff},
+    {0x82, 0x2924},
+    {0x83, 0x0892},
+    {0x84, 0x09cd},
+    {0x85, 0x11ab},
+    {0x86, 0x004b},
+    {0x87, 0x0000},
+    {0x88, 0x8000},
+    {0x89, 0x00aa},
+    {0x8a, 0x000a},
+    {0x8b, 0x0002},
+    {0x8c, 0x2002},
+    {0x8d, 0x0000},
+    {0x8e, 0x003f},
+    {0x8f, 0x79eb},
+    {0x90, 0x4eaf},
+    {0x91, 0x0001},
+    {0x92, 0x0138},
+    {0x93, 0x0384},
+    {0x94, 0x0000},
+    {0x95, 0x1728},
+    {0x96, 0x001a},
+    {0x97, 0x0008},
+    {0x98, 0x0000},
+    {0x99, 0x040a},
+    {0x9a, 0x0010},
+    {0x9b, 0x0090},
+    {0x9c, 0x0a3e},
+    {0x9d, 0x0a2c},
+    {0x9e, 0x2528},
+    {0x9f, 0x0806},
+    {0xa0, 0x0c0a},
+    {0xa1, 0x0011},
+    {0xa2, 0x001e},
+    {0xa3, 0x0186},
+    {0xa4, 0x03fc},
+    {0xa5, 0x000c},
+    {0xa6, 0x0002},
+    {0xa7, 0x0000},
+    {0xa8, 0x0000},
+    {0xa9, 0x0000},
+    {0xaa, 0x0000},
+    {0xab, 0x0000},
+    {0xac, 0x0000},
+    {0xad, 0x0000},
+    {0xae, 0x0000},
+    {0xaf, 0x0000},
+    {0xb0, 0x0000},
+    {0xb1, 0x0000},
+    {0xb2, 0x0439},
+    {0xb3, 0x0000},
+    {0xb4, 0x000c},
+    {0xb5, 0x0000},
+    {0xb6, 0x8ce0},
+    {0xb7, 0x002b},
+    {TOPAZ2M_TABLE_END, TOPAZ2M_TABLE_END_VAL}
+};
+
+/* 1920x800@80fps, 2 lanes, line length = 650, RAW10, color mode */
+static topaz2m_reg mode_1920x800_10b_color[] = {
+    {TOPAZ2M_TABLE_WAIT_MS, 10},
+    {0x04, 0xa2d0},
+    {0x05, 0x0015},
+    {0x06, 0x028a},
+    {0x07, 0x03c1},
+    {0x08, 0x0000},
+    {0x09, 0x0000},
+    {0x0a, 0x1a1f},
+    {0x0b, 0x0320},
+    {0x0c, 0x0000},
+    {0x0d, 0x0000},
+    {0x0e, 0x0100},
+    {0x0f, 0x0320},
+    {0x10, 0x0780},
+    {0x11, 0x008C},
+    {0x12, 0x0000},
+    {0x13, 0x0000},
+    {0x14, 0x0005},
+    {0x15, 0x0000},
+    {0x16, 0x0000},
+    {0x17, 0x0100},
+    {0x18, 0x0438},
+    {0x19, 0x0000},
+    {0x1a, 0x0000},
+    {0x1b, 0x0000},
+    {0x1c, 0x0000},
+    {0x1d, 0x0000},
+    {0x1e, 0x0100},
+    {0x1f, 0x0100},
+    {0x20, 0x0100},
+    {0x21, 0x0100},
+    {0x22, 0x0000},
+    {0x23, 0x0000},
+    {0x24, 0x0000},
+    {0x25, 0x0009},
+    {0x26, 0x0000},
+    {0x27, 0x1068},
+    {0x28, 0x015e},
+    {0x29, 0x0782},
+    {0x2a, 0x0008},
+    {0x2b, 0x040d},
+    {0x2c, 0x020d},
+    {0x2d, 0x104c},
+    {0x2e, 0x001f},
+    {0x2f, 0x0020},
+    {0x30, 0x0000},
+    {0x80, 0x3f87},
+    {0x81, 0x17ff},
+    {0x82, 0x2924},
+    {0x83, 0x0892},
+    {0x84, 0x09cd},
+    {0x85, 0x11ab},
+    {0x86, 0x004b},
+    {0x87, 0x0000},
+    {0x88, 0x8000},
+    {0x89, 0x00aa},
+    {0x8a, 0x000a},
+    {0x8b, 0x0002},
+    {0x8c, 0x2002},
+    {0x8d, 0x0000},
+    {0x8e, 0x003f},
+    {0x8f, 0x79eb},
+    {0x90, 0x4eaf},
+    {0x91, 0x0001},
+    {0x92, 0x0138},
+    {0x93, 0x0384},
+    {0x94, 0x0000},
+    {0x95, 0x1728},
+    {0x96, 0x001a},
+    {0x97, 0x0008},
+    {0x98, 0x0000},
+    {0x99, 0x040a},
+    {0x9a, 0x0010},
+    {0x9b, 0x0090},
+    {0x9c, 0x0a3e},
+    {0x9d, 0x0a2c},
+    {0x9e, 0x2528},
+    {0x9f, 0x0806},
+    {0xa0, 0x0c0a},
+    {0xa1, 0x0011},
+    {0xa2, 0x001e},
+    {0xa3, 0x0186},
+    {0xa4, 0x03fc},
+    {0xa5, 0x000c},
+    {0xa6, 0x0002},
+    {0xa7, 0x0000},
+    {0xa8, 0x0000},
+    {0xa9, 0x0000},
+    {0xaa, 0x0000},
+    {0xab, 0x0000},
+    {0xac, 0x0000},
+    {0xad, 0x0000},
+    {0xae, 0x0000},
+    {0xaf, 0x0000},
+    {0xb0, 0x0000},
+    {0xb1, 0x0000},
+    {0xb2, 0x0439},
+    {0xb3, 0x0000},
+    {0xb4, 0x000c},
+    {0xb5, 0x0000},
+    {0xb6, 0x8ce0},
+    {0xb7, 0x002b},
+    {TOPAZ2M_TABLE_END, TOPAZ2M_TABLE_END_VAL}
+};
+
+/* 1920x800@130fps, 2 lanes, line length = 425, RAW8, color mode */
+static topaz2m_reg mode_1920x800_8b_color[] = {
+    {TOPAZ2M_TABLE_WAIT_MS, 10},
+    {0x04, 0xa2d0},
+    {0x05, 0x001a},
+    {0x06, 0x01a9},
+    {0x07, 0x0389},
+    {0x08, 0x0000},
+    {0x09, 0x0000},
+    {0x0a, 0x1a1f},
+    {0x0b, 0x0320},
+    {0x0c, 0x0000},
+    {0x0d, 0x0000},
+    {0x0e, 0x0100},
+    {0x0f, 0x0320},
+    {0x10, 0x0780},
+    {0x11, 0x008C},
+    {0x12, 0x0000},
+    {0x13, 0x0000},
+    {0x14, 0x0005},
+    {0x15, 0x0000},
+    {0x16, 0x0000},
+    {0x17, 0x0100},
+    {0x18, 0x0438},
+    {0x19, 0x0000},
+    {0x1a, 0x0000},
+    {0x1b, 0x0000},
+    {0x1c, 0x0000},
+    {0x1d, 0x0000},
+    {0x1e, 0x0100},
+    {0x1f, 0x0100},
+    {0x20, 0x0100},
+    {0x21, 0x0100},
+    {0x22, 0x0000},
+    {0x23, 0x0000},
+    {0x24, 0x0000},
+    {0x25, 0x0009},
+    {0x26, 0x0000},
+    {0x27, 0x1068},
+    {0x28, 0x015e},
+    {0x29, 0x0782},
+    {0x2a, 0x0008},
+    {0x2b, 0x040d},
+    {0x2c, 0x020d},
+    {0x2d, 0x104c},
+    {0x2e, 0x001f},
+    {0x2f, 0x0020},
+    {0x30, 0x0000},
+    {0x80, 0x3f87},
+    {0x81, 0x17ff},
+    {0x82, 0x2924},
+    {0x83, 0x0892},
+    {0x84, 0x09cd},
+    {0x85, 0x11ab},
+    {0x86, 0x004b},
+    {0x87, 0x0000},
+    {0x88, 0x8000},
+    {0x89, 0x00aa},
+    {0x8a, 0x000a},
+    {0x8b, 0x0002},
+    {0x8c, 0x2002},
+    {0x8d, 0x0000},
+    {0x8e, 0x003f},
+    {0x8f, 0x79eb},
+    {0x90, 0x4eaf},
+    {0x91, 0x0001},
+    {0x92, 0x0138},
+    {0x93, 0x0384},
+    {0x94, 0x0000},
+    {0x95, 0x1728},
+    {0x96, 0x001a},
+    {0x97, 0x0008},
+    {0x98, 0x0000},
+    {0x99, 0x040a},
+    {0x9a, 0x0010},
+    {0x9b, 0x0090},
+    {0x9c, 0x0a3e},
+    {0x9d, 0x0a2c},
+    {0x9e, 0x2528},
+    {0x9f, 0x0806},
+    {0xa0, 0x0c0a},
+    {0xa1, 0x0011},
+    {0xa2, 0x001e},
+    {0xa3, 0x0186},
+    {0xa4, 0x03fc},
+    {0xa5, 0x000c},
+    {0xa6, 0x0002},
+    {0xa7, 0x0000},
+    {0xa8, 0x0000},
+    {0xa9, 0x0000},
+    {0xaa, 0x0000},
+    {0xab, 0x0000},
+    {0xac, 0x0000},
+    {0xad, 0x0000},
+    {0xae, 0x0000},
+    {0xaf, 0x0000},
+    {0xb0, 0x0000},
+    {0xb1, 0x0000},
+    {0xb2, 0x0439},
+    {0xb3, 0x0000},
+    {0xb4, 0x000c},
+    {0xb5, 0x0000},
+    {0xb6, 0x8ce0},
+    {0xb7, 0x002b},
+    {TOPAZ2M_TABLE_END, TOPAZ2M_TABLE_END_VAL}
+};
+
+static topaz2m_reg topaz2m_start[] = {
+    {0x02, 0x0008},
+    {TOPAZ2M_TABLE_END, TOPAZ2M_TABLE_END_VAL}
+};
+
+static topaz2m_reg topaz2m_stop[] = {
+    {0x02, 0x0001},
+    {TOPAZ2M_TABLE_END, TOPAZ2M_TABLE_END_VAL}
+};
+
+enum {
+    TOPAZ2M_MODE_1920X1080_10B_INT_SELF_TRIG,
+    TOPAZ2M_MODE_1920X800_10B_INT_SELF_TRIG,
+    TOPAZ2M_MODE_1920X1080_8B_INT_SELF_TRIG,
+    TOPAZ2M_MODE_1920X800_8B_INT_SELF_TRIG,
+    TOPAZ2M_MODE_1920X1080_10B_EXT_FRAME_TRIG,
+    TOPAZ2M_MODE_1920X800_10B_EXT_FRAME_TRIG,
+    TOPAZ2M_MODE_1920X1080_8B_EXT_FRAME_TRIG,
+    TOPAZ2M_MODE_1920X800_8B_EXT_FRAME_TRIG,
+    TOPAZ2M_MODE_1920X1080_10B_EXT_ITC_TRIG,
+    TOPAZ2M_MODE_1920X800_10B_EXT_ITC_TRIG,
+    TOPAZ2M_MODE_1920X1080_8B_EXT_ITC_TRIG,
+    TOPAZ2M_MODE_1920X800_8B_EXT_ITC_TRIG,
+    TOPAZ2M_MODE_START_STREAM,
+    TOPAZ2M_MODE_STOP_STREAM,
+    TOPAZ2M_MODE_COMMON,
+};
+
+static topaz2m_reg *mode_table_bw[] = {
+    [TOPAZ2M_MODE_COMMON] = mode_table_common,
+    [TOPAZ2M_MODE_1920X1080_10B_INT_SELF_TRIG] = mode_1920x1080_10b,
+    [TOPAZ2M_MODE_1920X800_10B_INT_SELF_TRIG] = mode_1920x800_10b,
+    [TOPAZ2M_MODE_1920X1080_8B_INT_SELF_TRIG] = mode_1920x1080_8b,
+    [TOPAZ2M_MODE_1920X800_8B_INT_SELF_TRIG] = mode_1920x800_8b,
+    [TOPAZ2M_MODE_1920X1080_10B_EXT_FRAME_TRIG] = mode_1920x1080_10b,
+    [TOPAZ2M_MODE_1920X800_10B_EXT_FRAME_TRIG] = mode_1920x800_10b,
+    [TOPAZ2M_MODE_1920X1080_8B_EXT_FRAME_TRIG] = mode_1920x1080_8b,
+    [TOPAZ2M_MODE_1920X800_8B_EXT_FRAME_TRIG] = mode_1920x800_8b,
+    [TOPAZ2M_MODE_1920X1080_10B_EXT_ITC_TRIG] = mode_1920x1080_10b,
+    [TOPAZ2M_MODE_1920X800_10B_EXT_ITC_TRIG] = mode_1920x800_10b,
+    [TOPAZ2M_MODE_1920X1080_8B_EXT_ITC_TRIG] = mode_1920x1080_8b,
+    [TOPAZ2M_MODE_1920X800_8B_EXT_ITC_TRIG] = mode_1920x800_8b,
+    [TOPAZ2M_MODE_START_STREAM] = topaz2m_start,
+    [TOPAZ2M_MODE_STOP_STREAM] = topaz2m_stop,
+};
+
+static topaz2m_reg *mode_table_color[] = {
+    [TOPAZ2M_MODE_COMMON] = mode_table_common,
+    [TOPAZ2M_MODE_1920X1080_10B_INT_SELF_TRIG] = mode_1920x1080_10b_color,
+    [TOPAZ2M_MODE_1920X800_10B_INT_SELF_TRIG] = mode_1920x800_10b_color,
+    [TOPAZ2M_MODE_1920X1080_8B_INT_SELF_TRIG] = mode_1920x1080_8b_color,
+    [TOPAZ2M_MODE_1920X800_8B_INT_SELF_TRIG] = mode_1920x800_8b_color,
+    [TOPAZ2M_MODE_1920X1080_10B_EXT_FRAME_TRIG] = mode_1920x1080_10b_color,
+    [TOPAZ2M_MODE_1920X800_10B_EXT_FRAME_TRIG] = mode_1920x800_10b_color,
+    [TOPAZ2M_MODE_1920X1080_8B_EXT_FRAME_TRIG] = mode_1920x1080_8b_color,
+    [TOPAZ2M_MODE_1920X800_8B_EXT_FRAME_TRIG] = mode_1920x800_8b_color,
+    [TOPAZ2M_MODE_1920X1080_10B_EXT_ITC_TRIG] = mode_1920x1080_10b_color,
+    [TOPAZ2M_MODE_1920X800_10B_EXT_ITC_TRIG] = mode_1920x800_10b_color,
+    [TOPAZ2M_MODE_1920X1080_8B_EXT_ITC_TRIG] = mode_1920x1080_8b_color,
+    [TOPAZ2M_MODE_1920X800_8B_EXT_ITC_TRIG] = mode_1920x800_8b_color,
+    [TOPAZ2M_MODE_START_STREAM] = topaz2m_start,
+    [TOPAZ2M_MODE_STOP_STREAM] = topaz2m_stop,
+};
+
+static const int topaz2m_65fps[] = {
+    65,
+};
+
+static const int topaz2m_80fps[] = {
+    80,
+};
+
+static const int topaz2m_100fps[] = {
+    100,
+};
+
+static const int topaz2m_130fps[] = {
+    130,
+};
+
+static const struct camera_common_frmfmt topaz2m_frmfmt[] = {
+    {{1920, 1080}, topaz2m_65fps,  1, 0, TOPAZ2M_MODE_1920X1080_10B_INT_SELF_TRIG},
+    {{1920,  800}, topaz2m_80fps,  1, 0, TOPAZ2M_MODE_1920X800_10B_INT_SELF_TRIG},
+    {{1920, 1080}, topaz2m_100fps, 1, 0, TOPAZ2M_MODE_1920X1080_8B_INT_SELF_TRIG},
+    {{1920,  800}, topaz2m_130fps, 1, 0, TOPAZ2M_MODE_1920X800_8B_INT_SELF_TRIG},
+    {{1920, 1080}, topaz2m_65fps,  1, 0, TOPAZ2M_MODE_1920X1080_10B_EXT_FRAME_TRIG},
+    {{1920,  800}, topaz2m_80fps,  1, 0, TOPAZ2M_MODE_1920X800_10B_EXT_FRAME_TRIG},
+    {{1920, 1080}, topaz2m_100fps, 1, 0, TOPAZ2M_MODE_1920X1080_8B_EXT_FRAME_TRIG},
+    {{1920,  800}, topaz2m_130fps, 1, 0, TOPAZ2M_MODE_1920X800_8B_EXT_FRAME_TRIG},
+    {{1920, 1080}, topaz2m_65fps,  1, 0, TOPAZ2M_MODE_1920X1080_10B_EXT_ITC_TRIG},
+    {{1920,  800}, topaz2m_80fps,  1, 0, TOPAZ2M_MODE_1920X800_10B_EXT_ITC_TRIG},
+    {{1920, 1080}, topaz2m_100fps, 1, 0, TOPAZ2M_MODE_1920X1080_8B_EXT_ITC_TRIG},
+    {{1920,  800}, topaz2m_130fps, 1, 0, TOPAZ2M_MODE_1920X800_8B_EXT_ITC_TRIG},
+};
+
+#endif
diff --git a/kernel/nvidia/drivers/media/platform/tegra/camera/camera_common.c b/kernel/nvidia/drivers/media/platform/tegra/camera/camera_common.c
index 2b0b341b0..0592353c6 100644
--- a/kernel/nvidia/drivers/media/platform/tegra/camera/camera_common.c
+++ b/kernel/nvidia/drivers/media/platform/tegra/camera/camera_common.c
@@ -46,6 +46,16 @@
 #define HDR_ENABLE		0x1
 
 static const struct camera_common_colorfmt camera_common_color_fmts[] = {
+	{
+		MEDIA_BUS_FMT_Y8_1X8,
+		V4L2_COLORSPACE_SRGB,
+		V4L2_PIX_FMT_GREY,
+	},
+	{
+		MEDIA_BUS_FMT_Y10_1X10,
+		V4L2_COLORSPACE_SRGB,
+		V4L2_PIX_FMT_Y10,
+	},
 	{
 		MEDIA_BUS_FMT_SRGGB12_1X12,
 		V4L2_COLORSPACE_SRGB,
diff --git a/kernel/nvidia/drivers/media/platform/tegra/camera/sensor_common.c b/kernel/nvidia/drivers/media/platform/tegra/camera/sensor_common.c
index d50b22e49..180d7ec9e 100644
--- a/kernel/nvidia/drivers/media/platform/tegra/camera/sensor_common.c
+++ b/kernel/nvidia/drivers/media/platform/tegra/camera/sensor_common.c
@@ -237,6 +237,10 @@ static int extract_pixel_format(
 
 	if (strncmp(pixel_t, "bayer_bggr10", size) == 0)
 		*format = V4L2_PIX_FMT_SBGGR10;
+	else if (strncmp(pixel_t, "grey_8", size) == 0)
+		*format = V4L2_PIX_FMT_GREY;
+	else if (strncmp(pixel_t, "grey_10", size) == 0)
+		*format = V4L2_PIX_FMT_Y10;
 	else if (strncmp(pixel_t, "bayer_rggb10", size) == 0)
 		*format = V4L2_PIX_FMT_SRGGB10;
 	else if (strncmp(pixel_t, "bayer_grbg10", size) == 0)
diff --git a/kernel/nvidia/drivers/media/platform/tegra/camera/tegracam_core.c b/kernel/nvidia/drivers/media/platform/tegra/camera/tegracam_core.c
index 04aaa6a9e..e928b244c 100644
--- a/kernel/nvidia/drivers/media/platform/tegra/camera/tegracam_core.c
+++ b/kernel/nvidia/drivers/media/platform/tegra/camera/tegracam_core.c
@@ -180,9 +180,9 @@ int tegracam_device_register(struct tegracam_device *tc_dev)
 	list_add(&tc_dev_entry->list, &tc_device_list_head);
 	mutex_unlock(&tc_device_list_mutex);
 
-	dev_info(dev, "tegracam sensor driver:%s_v%d.%d.%d\n",
-			tc_dev->name, TEGRACAM_MAJOR_VERSION,
-			TEGRACAM_MINOR_VERSION, TEGRACAM_PATCH_VERSION);
+	dev_info(dev, "tegracam v%d.%d.%d sensor driver: %s\n",
+			TEGRACAM_MAJOR_VERSION, TEGRACAM_MINOR_VERSION, TEGRACAM_PATCH_VERSION,
+			tc_dev->name);
 
 	return 0;
 }
diff --git a/kernel/nvidia/drivers/media/platform/tegra/camera/tegracam_ctrls.c b/kernel/nvidia/drivers/media/platform/tegra/camera/tegracam_ctrls.c
index c5cff21e0..1f1ddcc5c 100644
--- a/kernel/nvidia/drivers/media/platform/tegra/camera/tegracam_ctrls.c
+++ b/kernel/nvidia/drivers/media/platform/tegra/camera/tegracam_ctrls.c
@@ -35,10 +35,53 @@
 #define CTRL_MAX_STR_SIZE 4096
 #define STEREO_EEPROM_SIZE 4096
 
+#define TOPAZ2M_MIN_ANA_GAIN_VALUE          0x0000
+#define TOPAZ2M_MAX_ANA_GAIN_VALUE          0x000F
+#define TOPAZ2M_MIN_DIG_GAIN_VALUE          0x0001
+#define TOPAZ2M_DEF_DIG_GAIN_VALUE          0x0100
+#define TOPAZ2M_MAX_DIG_GAIN_VALUE          0x1000
+#define TOPAZ2M_MIN_TEST_PATTERN_VALUE      0x0000
+#define TOPAZ2M_MAX_TEST_PATTERN_VALUE      0x000D
+#define TOPAZ2M_MIN_FLIP_VALUE              0x0000
+#define TOPAZ2M_MAX_FLIP_VALUE              0x0003
+#define TOPAZ2M_MIN_COLOR_GAIN_VALUE        0x0000
+#define TOPAZ2M_DEF_COLOR_GAIN_VALUE        0x0100
+#define TOPAZ2M_MAX_COLOR_GAIN_VALUE        0x03FF
+#define TOPAZ2M_MIN_COLOR_OFFSET_VALUE      -128
+#define TOPAZ2M_DEF_COLOR_OFFSET_VALUE      0
+#define TOPAZ2M_MAX_COLOR_OFFSET_VALUE      127
+#define TOPAZ2M_MIN_TRIGGER_OUTPUT_VALUE    0x0
+#define TOPAZ2M_MAX_TRIGGER_OUTPUT_VALUE    0x9
+#define TOPAZ2M_MIN_FLASH_DELAY_ON_VALUE    0x00
+#define TOPAZ2M_MAX_FLASH_DELAY_ON_VALUE    0xFF
+#define TOPAZ2M_MIN_FLASH_DELAY_OFF_VALUE   0x00
+#define TOPAZ2M_MAX_FLASH_DELAY_OFF_VALUE   0xFF
+#define TOPAZ2M_MIN_IMAGE_OFFSET_VALUE      -512
+#define TOPAZ2M_DEF_IMAGE_OFFSET_VALUE      0
+#define TOPAZ2M_MAX_IMAGE_OFFSET_VALUE      511
+#define TOPAZ2M_MIN_MODULE_RESOLUTION_VALUE 1
+#define TOPAZ2M_MAX_MODULE_RESOLUTION_VALUE 5
+#define TOPAZ2M_MIN_MODULE_OPTION_VALUE     0
+#define TOPAZ2M_MAX_MODULE_OPTION_VALUE     2
+#define TOPAZ2M_MIN_IS_COLOR_VALUE          0
+#define TOPAZ2M_MAX_IS_COLOR_VALUE          1
+#define TOPAZ2M_MIN_IS_MULTIFOCUS_VALUE     0
+#define TOPAZ2M_MAX_IS_MULTIFOCUS_VALUE     1
+#define TOPAZ2M_MIN_FOCUS_DAC_VALUE         -146
+#define TOPAZ2M_DEF_FOCUS_DAC_VALUE         0
+#define TOPAZ2M_MAX_FOCUS_DAC_VALUE         885
+#define TOPAZ2M_MIN_TEMPERATURE_VALUE       -400000
+#define TOPAZ2M_DEF_TEMPERATURE_VALUE       0
+#define TOPAZ2M_MAX_TEMPERATURE_VALUE       1250000
+#define TOPAZ2M_MIN_TEMPERATURE_RANGE_VALUE 0
+#define TOPAZ2M_MAX_TEMPERATURE_RANGE_VALUE 1
+
 #define TEGRACAM_DEF_CTRLS 1
 
+static int tegracam_g_volatile_ctrl(struct v4l2_ctrl *ctrl);
 static int tegracam_s_ctrl(struct v4l2_ctrl *ctrl);
 static const struct v4l2_ctrl_ops tegracam_ctrl_ops = {
+	.g_volatile_ctrl = tegracam_g_volatile_ctrl,
 	.s_ctrl = tegracam_s_ctrl,
 };
 
@@ -191,6 +234,259 @@ static struct v4l2_ctrl_config ctrl_cfg_list[] = {
 		.min = CTRL_U8_MIN,
 		.max = CTRL_U8_MAX,
 		.step = 1,
+		},
+	{
+		.ops = &tegracam_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_ANA_GAIN,
+		.name = "Analog Gain",
+		.type = V4L2_CTRL_TYPE_INTEGER64,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = TOPAZ2M_MIN_ANA_GAIN_VALUE,
+		.max = TOPAZ2M_MAX_ANA_GAIN_VALUE,
+		.def = TOPAZ2M_MIN_ANA_GAIN_VALUE,
+		.step = 1,
+	},
+	{
+		.ops = &tegracam_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_DIG_GAIN,
+		.name = "Digital Gain",
+		.type = V4L2_CTRL_TYPE_INTEGER64,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = TOPAZ2M_MIN_DIG_GAIN_VALUE,
+		.max = TOPAZ2M_MAX_DIG_GAIN_VALUE,
+		.def = TOPAZ2M_DEF_DIG_GAIN_VALUE,
+		.step = 1,
+	 },
+	{
+		.ops = &tegracam_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_TEST_PATTERN,
+		.name = "Test pattern",
+		.type = V4L2_CTRL_TYPE_INTEGER64,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = TOPAZ2M_MIN_TEST_PATTERN_VALUE,
+		.max = TOPAZ2M_MAX_TEST_PATTERN_VALUE,
+		.def = TOPAZ2M_MIN_TEST_PATTERN_VALUE,
+		.step = 1,
+	 },
+	{
+		.ops = &tegracam_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_FLIP,
+		.name = "Flip",
+		.type = V4L2_CTRL_TYPE_INTEGER64,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = TOPAZ2M_MIN_FLIP_VALUE,
+		.max = TOPAZ2M_MAX_FLIP_VALUE,
+		.def = TOPAZ2M_MIN_FLIP_VALUE,
+		.step = 1,
+	 },
+	{
+		.ops = &tegracam_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_COLOR_GAIN_B,
+		.name = "Color gain b",
+		.type = V4L2_CTRL_TYPE_INTEGER64,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = TOPAZ2M_MIN_COLOR_GAIN_VALUE,
+		.max = TOPAZ2M_MAX_COLOR_GAIN_VALUE,
+		.def = TOPAZ2M_DEF_COLOR_GAIN_VALUE,
+		.step = 1,
+	 },
+	{
+		.ops = &tegracam_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_COLOR_GAIN_G,
+		.name = "Color gain g",
+		.type = V4L2_CTRL_TYPE_INTEGER64,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = TOPAZ2M_MIN_COLOR_GAIN_VALUE,
+		.max = TOPAZ2M_MAX_COLOR_GAIN_VALUE,
+		.def = TOPAZ2M_DEF_COLOR_GAIN_VALUE,
+		.step = 1,
+	 },
+	{
+		.ops = &tegracam_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_COLOR_GAIN_R,
+		.name = "Color gain r",
+		.type = V4L2_CTRL_TYPE_INTEGER64,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = TOPAZ2M_MIN_COLOR_GAIN_VALUE,
+		.max = TOPAZ2M_MAX_COLOR_GAIN_VALUE,
+		.def = TOPAZ2M_DEF_COLOR_GAIN_VALUE,
+		.step = 1,
+	 },
+	 {
+		.ops = &tegracam_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_COLOR_OFFSET_B,
+		.name = "Color offset b",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = TOPAZ2M_MIN_COLOR_OFFSET_VALUE,
+		.max = TOPAZ2M_MAX_COLOR_OFFSET_VALUE,
+		.def = TOPAZ2M_DEF_COLOR_OFFSET_VALUE,
+		.step = 1,
+	 },
+	{
+		.ops = &tegracam_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_COLOR_OFFSET_G,
+		.name = "Color offset g",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = TOPAZ2M_MIN_COLOR_OFFSET_VALUE,
+		.max = TOPAZ2M_MAX_COLOR_OFFSET_VALUE,
+		.def = TOPAZ2M_DEF_COLOR_OFFSET_VALUE,
+		.step = 1,
+	 },
+	{
+		.ops = &tegracam_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_COLOR_OFFSET_R,
+		.name = "Color offset r",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = TOPAZ2M_MIN_COLOR_OFFSET_VALUE,
+		.max = TOPAZ2M_MAX_COLOR_OFFSET_VALUE,
+		.def = TOPAZ2M_DEF_COLOR_OFFSET_VALUE,
+		.step = 1,
+	 },
+	 {
+		.ops = &tegracam_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_TRIGGER_OUTPUT,
+		.name = "Trigger output",
+		.type = V4L2_CTRL_TYPE_INTEGER64,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = TOPAZ2M_MIN_TRIGGER_OUTPUT_VALUE,
+		.max = TOPAZ2M_MAX_TRIGGER_OUTPUT_VALUE,
+		.def = TOPAZ2M_MIN_TRIGGER_OUTPUT_VALUE,
+		.step = 1,
+	 },
+	 {
+		.ops = &tegracam_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_FLASH_DELAY_ON,
+		.name = "Flash delay on",
+		.type = V4L2_CTRL_TYPE_INTEGER64,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = TOPAZ2M_MIN_FLASH_DELAY_ON_VALUE,
+		.max = TOPAZ2M_MAX_FLASH_DELAY_ON_VALUE,
+		.def = TOPAZ2M_MIN_FLASH_DELAY_ON_VALUE,
+		.step = 1,
+	 },
+	 {
+		.ops = &tegracam_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_FLASH_DELAY_OFF,
+		.name = "Flash delay off",
+		.type = V4L2_CTRL_TYPE_INTEGER64,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = TOPAZ2M_MIN_FLASH_DELAY_OFF_VALUE,
+		.max = TOPAZ2M_MAX_FLASH_DELAY_OFF_VALUE,
+		.def = TOPAZ2M_MIN_FLASH_DELAY_OFF_VALUE,
+		.step = 1,
+	 },
+	 {
+		.ops = &tegracam_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_IMAGE_OFFSET,
+		.name = "Image offset",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = TOPAZ2M_MIN_IMAGE_OFFSET_VALUE,
+		.max = TOPAZ2M_MAX_IMAGE_OFFSET_VALUE,
+		.def = TOPAZ2M_DEF_IMAGE_OFFSET_VALUE,
+		.step = 1,
+	 },
+	 {
+		.ops = &tegracam_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_MODULE_RESOLUTION,
+		.name = "Module resolution",
+		.type = V4L2_CTRL_TYPE_INTEGER64,
+		.flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_READ_ONLY,
+		.min = TOPAZ2M_MIN_MODULE_RESOLUTION_VALUE,
+		.max = TOPAZ2M_MAX_MODULE_RESOLUTION_VALUE,
+		.def = TOPAZ2M_MIN_MODULE_RESOLUTION_VALUE,
+		.step = 1,
+	 },
+	 {
+		.ops = &tegracam_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_MODULE_OPTION,
+		.name = "Module option",
+		.type = V4L2_CTRL_TYPE_INTEGER64,
+		.flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_READ_ONLY,
+		.min = TOPAZ2M_MIN_MODULE_OPTION_VALUE,
+		.max = TOPAZ2M_MAX_MODULE_OPTION_VALUE,
+		.def = TOPAZ2M_MIN_MODULE_OPTION_VALUE,
+		.step = 1,
+	 },
+	 {
+		.ops = &tegracam_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_IS_COLOR,
+		.name = "Is color",
+		.type = V4L2_CTRL_TYPE_INTEGER64,
+		.flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_READ_ONLY,
+		.min = TOPAZ2M_MIN_IS_COLOR_VALUE,
+		.max = TOPAZ2M_MAX_IS_COLOR_VALUE,
+		.def = TOPAZ2M_MIN_IS_COLOR_VALUE,
+		.step = 1,
+	 },
+	 {
+		.ops = &tegracam_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_IS_MULTIFOCUS,
+		.name = "Is multifocus",
+		.type = V4L2_CTRL_TYPE_INTEGER64,
+		.flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_READ_ONLY,
+		.min = TOPAZ2M_MIN_IS_MULTIFOCUS_VALUE,
+		.max = TOPAZ2M_MAX_IS_MULTIFOCUS_VALUE,
+		.def = TOPAZ2M_MIN_IS_MULTIFOCUS_VALUE,
+		.step = 1,
+	 },
+	 {
+		.ops = &tegracam_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_WRITE_FOCUS_DAC,
+		.name = "Write Focus DAC",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = TOPAZ2M_MIN_FOCUS_DAC_VALUE,
+		.max = TOPAZ2M_MAX_FOCUS_DAC_VALUE,
+		.def = TOPAZ2M_DEF_FOCUS_DAC_VALUE,
+		.step = 1,
+	 },
+	 {
+		.ops = &tegracam_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_READ_FOCUS_DAC,
+		.name = "Read Focus DAC",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_READ_ONLY,
+		.min = TOPAZ2M_MIN_FOCUS_DAC_VALUE,
+		.max = TOPAZ2M_MAX_FOCUS_DAC_VALUE,
+		.def = TOPAZ2M_DEF_FOCUS_DAC_VALUE,
+		.step = 1,
+	 },
+	 {
+		.ops = &tegracam_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_MODULE_TEMPERATURE,
+		.name = "Module temperature",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_READ_ONLY,
+		.min = TOPAZ2M_MIN_TEMPERATURE_VALUE,
+		.max = TOPAZ2M_MAX_TEMPERATURE_VALUE,
+		.def = TOPAZ2M_DEF_TEMPERATURE_VALUE,
+		.step = 1,
+	 },
+	 {
+		.ops = &tegracam_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_SENSOR_TEMPERATURE,
+		.name = "Sensor temperature",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.flags = V4L2_CTRL_FLAG_VOLATILE | V4L2_CTRL_FLAG_READ_ONLY,
+		.min = TOPAZ2M_MIN_TEMPERATURE_VALUE,
+		.max = TOPAZ2M_MAX_TEMPERATURE_VALUE,
+		.def = TOPAZ2M_DEF_TEMPERATURE_VALUE,
+		.step = 1,
+	 },
+	 {
+		.ops = &tegracam_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_TEMPERATURE_RANGE,
+		.name = "Temperature range",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = TOPAZ2M_MIN_TEMPERATURE_RANGE_VALUE,
+		.max = TOPAZ2M_MAX_TEMPERATURE_RANGE_VALUE,
+		.def = TOPAZ2M_MIN_TEMPERATURE_RANGE_VALUE,
+		.step = 1,
 	},
 };
 
@@ -356,6 +652,54 @@ static int tegracam_set_ctrls(struct tegracam_ctrl_handler *handler,
 		err = ops->set_alternating_exposure(tc_dev,
 			(struct alternating_exposure_cfg *)ctrl->p_new.p);
 		break;
+	case TEGRA_CAMERA_CID_ANA_GAIN:
+		err = ops->set_analog_gain(tc_dev, *ctrl->p_new.p_s64);
+		break;
+	case TEGRA_CAMERA_CID_DIG_GAIN:
+		err = ops->set_digital_gain(tc_dev, *ctrl->p_new.p_s64);
+		break;
+	case TEGRA_CAMERA_CID_TEST_PATTERN:
+		err = ops->set_test_pattern(tc_dev, *ctrl->p_new.p_s64);
+		break;
+	case TEGRA_CAMERA_CID_FLIP:
+		err = ops->set_flip(tc_dev, *ctrl->p_new.p_s64);
+		break;
+	case TEGRA_CAMERA_CID_COLOR_GAIN_B:
+		err = ops->set_color_gain_b(tc_dev, *ctrl->p_new.p_s64);
+		break;
+	case TEGRA_CAMERA_CID_COLOR_GAIN_G:
+		err = ops->set_color_gain_g(tc_dev, *ctrl->p_new.p_s64);
+		break;
+	case TEGRA_CAMERA_CID_COLOR_GAIN_R:
+		err = ops->set_color_gain_r(tc_dev, *ctrl->p_new.p_s64);
+		break;
+	case TEGRA_CAMERA_CID_COLOR_OFFSET_B:
+		err = ops->set_color_offset_b(tc_dev, *ctrl->p_new.p_s64);
+		break;
+	case TEGRA_CAMERA_CID_COLOR_OFFSET_G:
+		err = ops->set_color_offset_g(tc_dev, *ctrl->p_new.p_s64);
+		break;
+	case TEGRA_CAMERA_CID_COLOR_OFFSET_R:
+		err = ops->set_color_offset_r(tc_dev, *ctrl->p_new.p_s64);
+		break;
+	case TEGRA_CAMERA_CID_TRIGGER_OUTPUT:
+		err = ops->set_trigger_output(tc_dev, *ctrl->p_new.p_s64);
+		break;
+	case TEGRA_CAMERA_CID_FLASH_DELAY_ON:
+		err = ops->set_flash_delay_on(tc_dev, *ctrl->p_new.p_s64);
+		break;
+	case TEGRA_CAMERA_CID_FLASH_DELAY_OFF:
+		err = ops->set_flash_delay_off(tc_dev, *ctrl->p_new.p_s64);
+		break;
+	case TEGRA_CAMERA_CID_IMAGE_OFFSET:
+		err = ops->set_image_offset(tc_dev, *ctrl->p_new.p_s64);
+		break;
+	case TEGRA_CAMERA_CID_WRITE_FOCUS_DAC:
+		err = ops->set_focus_dac(tc_dev, *ctrl->p_new.p_s64);
+		break;
+	case TEGRA_CAMERA_CID_TEMPERATURE_RANGE:
+		err = ops->set_temperature_range(tc_dev, *ctrl->p_new.p_s64);
+		break;
 	default:
 		pr_err("%s: unknown ctrl id.\n", __func__);
 		return -EINVAL;
@@ -436,6 +780,69 @@ static int tegracam_set_ctrls_ex(struct tegracam_ctrl_handler *handler,
 	return err;
 }
 
+static int tegracam_g_volatile_ctrl(struct v4l2_ctrl *ctrl) {
+	struct tegracam_ctrl_handler *handler = NULL;
+	const struct tegracam_ctrl_ops *ops = NULL;
+	struct tegracam_device *tc_dev = NULL;
+	int err = 0;
+	s64 value = 0;
+
+	if (!ctrl) {
+		pr_err("%s:%d ctrl is null", __FUNCTION__, __LINE__);
+		err = -EINVAL;
+		goto exit;
+	}
+
+	handler = container_of(ctrl->handler, struct tegracam_ctrl_handler, ctrl_handler);
+	ops = handler->ctrl_ops;
+	tc_dev = handler->tc_dev;
+
+	switch(ctrl->id) {
+	case TEGRA_CAMERA_CID_MODULE_RESOLUTION: {
+		err = ops->get_module_resolution(tc_dev, &value);
+		break;
+	}
+	case TEGRA_CAMERA_CID_MODULE_OPTION: {
+		err = ops->get_module_option(tc_dev, &value);
+		break;
+	}
+	case TEGRA_CAMERA_CID_IS_COLOR: {
+		err = ops->get_is_color(tc_dev, &value);
+		break;
+	}
+	case TEGRA_CAMERA_CID_IS_MULTIFOCUS: {
+		err = ops->get_is_multifocus(tc_dev, &value);
+		break;
+	}
+	case TEGRA_CAMERA_CID_READ_FOCUS_DAC: {
+		err = ops->get_focus_dac(tc_dev, &value);
+		break;
+	}
+	case TEGRA_CAMERA_CID_MODULE_TEMPERATURE: {
+		err = ops->get_module_temperature(tc_dev, &value);
+		break;
+	}
+	case TEGRA_CAMERA_CID_SENSOR_TEMPERATURE: {
+		err = ops->get_sensor_temperature(tc_dev, &value);
+		break;
+	}
+	default: {
+		pr_err("%s: unknown ctrl id: %08x (%s)\n", __func__, ctrl->id,
+				v4l2_ctrl_get_name(ctrl->id));
+		err = -EINVAL;
+		break;
+	}
+	}
+
+	if (err) {
+		goto exit;
+	}
+
+	*ctrl->p_new.p_s64 = value;
+
+exit:
+	return err;
+}
 
 static int tegracam_s_ctrl(struct v4l2_ctrl *ctrl)
 {
@@ -779,9 +1186,170 @@ static int tegracam_check_ctrl_ops(
 			if (ops->set_frame_rate_ex != NULL)
 				sensor_ex_ops++;
 			break;
+				case TEGRA_CAMERA_CID_ANA_GAIN:
+			if (ops->set_analog_gain == NULL)
+				dev_err(dev,
+					"Missing TEGRA_CAMERA_CID_ANA_GAIN implementation\n");
+			else
+				sensor_ops++;
+			break;
+		case TEGRA_CAMERA_CID_DIG_GAIN:
+			if (ops->set_digital_gain == NULL)
+				dev_err(dev,
+					"Missing TEGRA_CAMERA_CID_DIG_GAIN implementation\n");
+			else
+				sensor_ops++;
+			break;
+		case TEGRA_CAMERA_CID_TEST_PATTERN:
+			if (ops->set_test_pattern == NULL)
+				dev_err(dev,
+					"Missing TEGRA_CAMERA_CID_TEST_PATTERN implementation\n");
+			else
+				sensor_ops++;
+			break;
+		case TEGRA_CAMERA_CID_FLIP:
+			if (ops->set_flip == NULL)
+				dev_err(dev,
+					"Missing TEGRA_CAMERA_CID_FLIP implementation\n");
+			else
+				sensor_ops++;
+			break;
+		case TEGRA_CAMERA_CID_COLOR_GAIN_B:
+			if (ops->set_color_gain_b == NULL)
+				dev_err(dev,
+					"Missing TEGRA_CAMERA_CID_COLOR_GAIN_B implementation\n");
+			else
+				sensor_ops++;
+			break;
+		case TEGRA_CAMERA_CID_COLOR_GAIN_G:
+			if (ops->set_color_gain_g == NULL)
+				dev_err(dev,
+					"Missing TEGRA_CAMERA_CID_COLOR_GAIN_G implementation\n");
+			else
+				sensor_ops++;
+			break;
+		case TEGRA_CAMERA_CID_COLOR_GAIN_R:
+			if (ops->set_color_gain_r == NULL)
+				dev_err(dev,
+					"Missing TEGRA_CAMERA_CID_COLOR_GAIN_R implementation\n");
+			else
+				sensor_ops++;
+			break;
+		case TEGRA_CAMERA_CID_COLOR_OFFSET_B:
+			if (ops->set_color_offset_b == NULL)
+				dev_err(dev,
+					"Missing TEGRA_CAMERA_CID_COLOR_OFFSET_B implementation\n");
+			else
+				sensor_ops++;
+			break;
+		case TEGRA_CAMERA_CID_COLOR_OFFSET_G:
+			if (ops->set_color_offset_g == NULL)
+				dev_err(dev,
+					"Missing TEGRA_CAMERA_CID_COLOR_OFFSET_G implementation\n");
+			else
+				sensor_ops++;
+			break;
+		case TEGRA_CAMERA_CID_COLOR_OFFSET_R:
+			if (ops->set_color_offset_r == NULL)
+				dev_err(dev,
+					"Missing TEGRA_CAMERA_CID_COLOR_OFFSET_R implementation\n");
+			else
+				sensor_ops++;
+			break;
+		case TEGRA_CAMERA_CID_TRIGGER_OUTPUT:
+			if (ops->set_trigger_output == NULL)
+				dev_err(dev,
+					"Missing TEGRA_CAMERA_CID_TRIGGER_OUTPUT implementation\n");
+			else
+				sensor_ops++;
+			break;
+		case TEGRA_CAMERA_CID_FLASH_DELAY_ON:
+			if (ops->set_flash_delay_on == NULL)
+				dev_err(dev,
+					"Missing TEGRA_CAMERA_CID_FLASH_DELAY_ON implementation\n");
+			else
+				sensor_ops++;
+			break;
+		case TEGRA_CAMERA_CID_FLASH_DELAY_OFF:
+			if (ops->set_flash_delay_off == NULL)
+				dev_err(dev,
+					"Missing TEGRA_CAMERA_CID_FLASH_DELAY_OFF implementation\n");
+			else
+				sensor_ops++;
+			break;
+		case TEGRA_CAMERA_CID_IMAGE_OFFSET:
+			if (ops->set_image_offset == NULL)
+				dev_err(dev,
+					"Missing TEGRA_CAMERA_CID_IMAGE_OFFSET implementation\n");
+			else
+				sensor_ops++;
+			break;
+		case TEGRA_CAMERA_CID_MODULE_RESOLUTION:
+			if (ops->get_module_resolution == NULL)
+				dev_err(dev,
+					"Missing TEGRA_CAMERA_CID_MODULE_RESOLUTION implementation\n");
+			else
+				sensor_ops++;
+			break;
+		case TEGRA_CAMERA_CID_MODULE_OPTION:
+			if (ops->get_module_option == NULL)
+				dev_err(dev,
+					"Missing TEGRA_CAMERA_CID_MODULE_OPTION implementation\n");
+			else
+				sensor_ops++;
+			break;
+		case TEGRA_CAMERA_CID_IS_COLOR:
+			if (ops->get_is_color == NULL)
+				dev_err(dev,
+					"Missing TEGRA_CAMERA_CID_IS_COLOR implementation\n");
+			else
+				sensor_ops++;
+			break;
+		case TEGRA_CAMERA_CID_IS_MULTIFOCUS:
+			if (ops->get_is_multifocus == NULL)
+				dev_err(dev,
+					"Missing TEGRA_CAMERA_CID_IS_MULTIFOCUS implementation\n");
+			else
+				sensor_ops++;
+			break;
+		case TEGRA_CAMERA_CID_WRITE_FOCUS_DAC:
+			if (ops->set_focus_dac == NULL)
+				dev_err(dev,
+					"Missing TEGRA_CAMERA_CID_WRITE_FOCUS_DAC implementation\n");
+			else
+				sensor_ops++;
+			break;
+		case TEGRA_CAMERA_CID_READ_FOCUS_DAC:
+			if (ops->get_focus_dac == NULL)
+				dev_err(dev,
+					"Missing TEGRA_CAMERA_CID_READ_FOCUS_DAC implementation\n");
+			else
+				sensor_ops++;
+			break;
+		case TEGRA_CAMERA_CID_MODULE_TEMPERATURE:
+			if (ops->get_module_temperature == NULL)
+				dev_err(dev,
+					"Missing TEGRA_CAMERA_CID_LOCAL_TEMPERATURE implementation\n");
+			else
+				sensor_ops++;
+			break;
+		case TEGRA_CAMERA_CID_SENSOR_TEMPERATURE:
+			if (ops->get_sensor_temperature == NULL)
+				dev_err(dev,
+					"Missing TEGRA_CAMERA_CID_REMOTE_TEMPERATURE implementation\n");
+			else
+				sensor_ops++;
+			break;
+		case TEGRA_CAMERA_CID_TEMPERATURE_RANGE:
+			if (ops->set_temperature_range == NULL)
+				dev_err(dev,
+					"Missing TEGRA_CAMERA_CID_TEMPERATURE_RANGE implementation\n");
+			else
+				sensor_ops++;
+			break;
 		case TEGRA_CAMERA_CID_GROUP_HOLD:
 			dev_err(dev,
-				"TEGRA_CAMERA_CID_GROUP_HOLD contorl is enabled in framework by default, no need to add it in driver\n");
+				"TEGRA_CAMERA_CID_GROUP_HOLD control is enabled in framework by default, no need to add it in driver\n");
 			return -EINVAL;
 		case TEGRA_CAMERA_CID_EEPROM_DATA:
 			if (tegracam_get_string_ctrl_size(
diff --git a/kernel/nvidia/drivers/media/platform/tegra/camera/tegracam_v4l2.c b/kernel/nvidia/drivers/media/platform/tegra/camera/tegracam_v4l2.c
index 1afa2e64b..433c87ea1 100644
--- a/kernel/nvidia/drivers/media/platform/tegra/camera/tegracam_v4l2.c
+++ b/kernel/nvidia/drivers/media/platform/tegra/camera/tegracam_v4l2.c
@@ -197,6 +197,17 @@ static const struct media_entity_operations media_ops = {
 	.link_validate = v4l2_subdev_link_validate,
 };
 
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+void tegracam_v4l2subdev_set_debug_register_controls(
+				const struct v4l2_subdev_core_ops *debug_register_ops) {
+	if (!debug_register_ops) {
+		return;
+	}
+	v4l2sd_core_ops.g_register = debug_register_ops->g_register;
+	v4l2sd_core_ops.s_register = debug_register_ops->s_register;
+}
+#endif /* CONFIG_VIDEO_ADV_DEBUG */
+
 int tegracam_v4l2subdev_register(struct tegracam_device *tc_dev,
 				bool is_sensor)
 {
diff --git a/kernel/nvidia/drivers/media/platform/tegra/camera/vi/vi2_formats.h b/kernel/nvidia/drivers/media/platform/tegra/camera/vi/vi2_formats.h
index fed27b9bf..0f70e2f8e 100644
--- a/kernel/nvidia/drivers/media/platform/tegra/camera/vi/vi2_formats.h
+++ b/kernel/nvidia/drivers/media/platform/tegra/camera/vi/vi2_formats.h
@@ -72,6 +72,12 @@ static const struct tegra_video_format vi2_video_formats[] = {
 
 	/* RAW 7: TODO */
 
+	/* GREY */
+	TEGRA_VIDEO_FORMAT(RAW8, 8, Y8_1X8, 1, 1, T_L8,
+				RAW8, GREY, "GREY8"),
+	TEGRA_VIDEO_FORMAT(RAW10, 10, Y10_1X10, 2, 1, T_R16_I,
+				RAW10, Y10, "Y10"),
+
 	/* RAW 8 */
 	TEGRA_VIDEO_FORMAT(RAW8, 8, SRGGB8_1X8, 1, 1, T_L8,
 				RAW8, SRGGB8, "RGRG.. GBGB.."),
diff --git a/kernel/nvidia/drivers/media/platform/tegra/camera/vi/vi4_formats.h b/kernel/nvidia/drivers/media/platform/tegra/camera/vi/vi4_formats.h
index de33c42fb..176141e77 100644
--- a/kernel/nvidia/drivers/media/platform/tegra/camera/vi/vi4_formats.h
+++ b/kernel/nvidia/drivers/media/platform/tegra/camera/vi/vi4_formats.h
@@ -86,6 +86,12 @@ static const struct tegra_video_format vi4_video_formats[] = {
 
 	/* RAW 7: TODO */
 
+	/* GREY */
+	TEGRA_VIDEO_FORMAT(RAW8, 8, Y8_1X8, 1, 1, T_L8,
+				RAW8, GREY, "GREY8"),
+	TEGRA_VIDEO_FORMAT(RAW10, 10, Y10_1X10, 2, 1, T_R16_I,
+				RAW10, Y10, "Y10"),
+
 	/* RAW 8 */
 	TEGRA_VIDEO_FORMAT(RAW8, 8, SRGGB8_1X8, 1, 1, T_L8,
 				RAW8, SRGGB8, "RGRG.. GBGB.."),
diff --git a/kernel/nvidia/drivers/media/platform/tegra/camera/vi/vi5_formats.h b/kernel/nvidia/drivers/media/platform/tegra/camera/vi/vi5_formats.h
index 7ee3a6223..7d667eb21 100644
--- a/kernel/nvidia/drivers/media/platform/tegra/camera/vi/vi5_formats.h
+++ b/kernel/nvidia/drivers/media/platform/tegra/camera/vi/vi5_formats.h
@@ -86,6 +86,12 @@ static const struct tegra_video_format vi5_video_formats[] = {
 
 	/* RAW 7: TODO */
 
+	/* GREY */
+	TEGRA_VIDEO_FORMAT(RAW8, 8, Y8_1X8, 1, 1, T_R8,
+				RAW8, GREY, "GREY8"),
+	TEGRA_VIDEO_FORMAT(RAW10, 10, Y10_1X10, 2, 1, T_R16,
+				RAW10, Y10, "Y10"),
+
 	/* RAW 8 */
 	TEGRA_VIDEO_FORMAT(RAW8, 8, SRGGB8_1X8, 1, 1, T_R8,
 				RAW8, SRGGB8, "RGRG.. GBGB.."),
diff --git a/kernel/nvidia/include/media/camera_common.h b/kernel/nvidia/include/media/camera_common.h
index d4e00ad25..4725ecbb9 100644
--- a/kernel/nvidia/include/media/camera_common.h
+++ b/kernel/nvidia/include/media/camera_common.h
@@ -60,6 +60,11 @@ struct reg_16 {
 	u16 val;
 };
 
+struct reg_8_16 {
+	u8 addr;
+	u16 val;
+};
+
 struct camera_common_power_rail {
 	struct regulator *dvdd;
 	struct regulator *avdd;
@@ -214,6 +219,29 @@ struct tegracam_ctrl_ops {
 			struct sensor_blob *blob, s64 val);
 	int (*set_group_hold_ex)(struct tegracam_device *tc_dev,
 			struct sensor_blob *blob, bool val);
+	int (*set_analog_gain)(struct tegracam_device *tc_dev, s64 val);
+	int (*set_digital_gain)(struct tegracam_device *tc_dev, s64 val);
+	int (*set_test_pattern)(struct tegracam_device *tc_dev, s64 val);
+	int (*set_flip)(struct tegracam_device *tc_dev, s64 val);
+	int (*set_color_gain_b)(struct tegracam_device *tc_dev, s64 val);
+	int (*set_color_gain_g)(struct tegracam_device *tc_dev, s64 val);
+	int (*set_color_gain_r)(struct tegracam_device *tc_dev, s64 val);
+	int (*set_color_offset_b)(struct tegracam_device *tc_dev, s64 val);
+	int (*set_color_offset_g)(struct tegracam_device *tc_dev, s64 val);
+	int (*set_color_offset_r)(struct tegracam_device *tc_dev, s64 val);
+	int (*set_trigger_output)(struct tegracam_device *tc_dev, s64 val);
+	int (*set_flash_delay_on)(struct tegracam_device *tc_dev, s64 val);
+	int (*set_flash_delay_off)(struct tegracam_device *tc_dev, s64 val);
+	int (*set_image_offset)(struct tegracam_device *tc_dev, s64 val);
+	int (*get_module_resolution)(struct tegracam_device *tc_dev, s64 *val);
+	int (*get_module_option)(struct tegracam_device *tc_dev, s64 *val);
+	int (*get_is_color)(struct tegracam_device *tc_dev, s64 *val);
+	int (*get_is_multifocus)(struct tegracam_device *tc_dev, s64 *val);
+	int (*set_focus_dac)(struct tegracam_device *tc_dev, s64 val);
+	int (*get_focus_dac)(struct tegracam_device *tc_dev, s64 *val);
+	int (*get_module_temperature)(struct tegracam_device *tc_dev, s64 *val);
+	int (*get_sensor_temperature)(struct tegracam_device *tc_dev, s64 *val);
+	int (*set_temperature_range)(struct tegracam_device *tc_dev, s64 val);
 };
 
 struct tegracam_ctrl_handler {
diff --git a/kernel/nvidia/include/media/tegra-v4l2-camera.h b/kernel/nvidia/include/media/tegra-v4l2-camera.h
index 99b5e5b97..b529e3d09 100644
--- a/kernel/nvidia/include/media/tegra-v4l2-camera.h
+++ b/kernel/nvidia/include/media/tegra-v4l2-camera.h
@@ -60,12 +60,38 @@
 #define TEGRA_CAMERA_CID_LOW_LATENCY         (TEGRA_CAMERA_CID_BASE+109)
 #define TEGRA_CAMERA_CID_VI_PREFERRED_STRIDE (TEGRA_CAMERA_CID_BASE+110)
 
+enum CUSTOM_TEGRA_CAMERA_CID {
+	TEGRA_CAMERA_CID_ANA_GAIN = TEGRA_CAMERA_CID_BASE+111,
+	TEGRA_CAMERA_CID_DIG_GAIN,
+	TEGRA_CAMERA_CID_TEST_PATTERN,
+	TEGRA_CAMERA_CID_FLIP,
+	TEGRA_CAMERA_CID_COLOR_GAIN_B,
+	TEGRA_CAMERA_CID_COLOR_GAIN_G,
+	TEGRA_CAMERA_CID_COLOR_GAIN_R,
+	TEGRA_CAMERA_CID_COLOR_OFFSET_B,
+	TEGRA_CAMERA_CID_COLOR_OFFSET_G,
+	TEGRA_CAMERA_CID_COLOR_OFFSET_R,
+	TEGRA_CAMERA_CID_TRIGGER_OUTPUT,
+	TEGRA_CAMERA_CID_FLASH_DELAY_ON,
+	TEGRA_CAMERA_CID_FLASH_DELAY_OFF,
+	TEGRA_CAMERA_CID_IMAGE_OFFSET,
+	TEGRA_CAMERA_CID_MODULE_RESOLUTION,
+	TEGRA_CAMERA_CID_MODULE_OPTION,
+	TEGRA_CAMERA_CID_IS_COLOR,
+	TEGRA_CAMERA_CID_IS_MULTIFOCUS,
+	TEGRA_CAMERA_CID_WRITE_FOCUS_DAC,
+	TEGRA_CAMERA_CID_READ_FOCUS_DAC,
+	TEGRA_CAMERA_CID_MODULE_TEMPERATURE,
+	TEGRA_CAMERA_CID_SENSOR_TEMPERATURE,
+	TEGRA_CAMERA_CID_TEMPERATURE_RANGE,
+};
+
 /**
  * This is temporary with the current v4l2 infrastructure
  * currently discussing with upstream maintainers our proposals and
  * better approaches to resolve this
  */
-#define TEGRA_CAMERA_CID_SENSOR_MODES		(TEGRA_CAMERA_CID_BASE + 130)
+#define TEGRA_CAMERA_CID_SENSOR_MODES		(TEGRA_CAMERA_CID_BASE + 134)
 
 #define MAX_BUFFER_SIZE			32
 #define MAX_CID_CONTROLS		32
diff --git a/kernel/nvidia/include/media/tegracam_core.h b/kernel/nvidia/include/media/tegracam_core.h
index 5f55015d8..f4d4dc791 100644
--- a/kernel/nvidia/include/media/tegracam_core.h
+++ b/kernel/nvidia/include/media/tegracam_core.h
@@ -48,6 +48,11 @@ struct tegracam_device *to_tegracam_device(struct camera_common_data *data);
 void tegracam_set_privdata(struct tegracam_device *tc_dev, void *priv);
 void *tegracam_get_privdata(struct tegracam_device *tc_dev);
 
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+void tegracam_v4l2subdev_set_debug_register_controls(
+				const struct v4l2_subdev_core_ops *debug_register_ops);
+#endif /* CONFIG_VIDEO_ADV_DEBUG */
+
 int tegracam_v4l2subdev_register(struct tegracam_device *tc_dev,
 				bool is_sensor);
 void tegracam_v4l2subdev_unregister(struct tegracam_device *tc_dev);
-- 
2.25.1

